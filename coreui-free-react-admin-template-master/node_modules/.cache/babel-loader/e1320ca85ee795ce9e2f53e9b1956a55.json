{"ast":null,"code":"//\n// officegen: basic common code\n//\n// Please refer to README.md for this module's documentations.\n//\n// NOTE:\n// - Before changing this code please refer to the hacking the code section on README.md.\n//\n// Copyright (c) 2013 Ziv Barber;\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// 'Software'), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\nrequire(\"setimmediate\"); // To be compatible with all versions of node.js\n\n\n(function () {\n  var sys = require('util');\n\n  var events = require('events');\n\n  var Transform = require('stream').Transform || require('readable-stream/transform'); // Used by generate:\n\n\n  var archiver = require('archiver');\n\n  var fs = require('fs');\n\n  var PassThrough = require('stream').PassThrough || require('readable-stream/passthrough'); // Global data shared by all the officegen objects:\n\n\n  var officegenGlobals = {}; // Our internal global objects.\n\n  officegenGlobals.settings = {};\n  officegenGlobals.types = {};\n  officegenGlobals.docPrototypes = {};\n  officegenGlobals.resParserTypes = {};\n  /**\n   * The constructor of the office generator object.\n   * <br /><br />\n   * This constructor function is been called by makegen().\n   *\n   * <h3><b>The options:</b></h3>\n   *\n   * The configuration options effecting the operation of the officegen object. Some of them can be only been \n   * declared on the 'options' object passed to the constructor object and the rest can be configured by either \n   * a property with the same name or by special function.\n   *\n   * <h3><b>List of options:</b></h3>\n   *\n   * <ul>\n   * <li>'type' - the type of generator to create. Possible options: either 'pptx', 'docx' or 'xlsx'.</li>\n   * <li>'creator' - the name of the document's author. The default is 'officegen'.</li>\n   * <li>'onend' - callback that been fired after finishing to create the zip stream.</li>\n   * <li>'onerr' - callback that been fired on error.</li>\n   * </ul>\n   *\n   * @param {object} options List of configuration options (see in the description of this function).\n   * @constructor\n   * @name officegen\n   */\n\n  var officegen = function officegen(options) {\n    if (false === this instanceof officegen) {\n      return new officegen(options);\n    } // Endif.\n\n\n    events.EventEmitter.call(this); // Transform.call ( this, { objectMode : true } );\n    // Internal events for plugins - NOT for the user:\n    // event 'beforeGen'\n    // event 'afterGen'\n    // event 'clearDoc'\n\n    var genobj = this; // Can be accessed by all the functions been declared inside the officegen object.\n\n    /**\n     * For all the private data of each officegen instance that we don't want the user of officegen to access it.\n     * Each officegen object has it's own copy of the private object so changes been done to the private object of one officegen document will not effect other objects.\n     * <br /><br />\n     * List of data members:\n     * <ul>\n     * <li>features (object) - ???.</li>\n     * <ul>\n     * <li>type</li>\n     * <li>outputType (string) - The type of the container to hold all the resources.</li>\n     * </ul>\n     * <li>pages</li>\n     * <li>resources</li>\n     * <li>type</li>\n     * <li>plugs</li>\n     * <li>length</li>\n     * </ul>\n     * @namespace officegen#private\n     */\n\n    var privateData = {}; // Features been configured by the type selector and you can't change them:\n\n    privateData.features = {};\n    privateData.features.type = {};\n    privateData.features.outputType = 'zip'; // privateData.features.page_name\n    // Resources and \"pages\" of the document:\n\n    privateData.pages = []; // Information about all the pages to create.\n\n    privateData.resources = []; // List of all the resources to create inside the zip.\n    // Extra data needed by the document and it's specific to either to \"document prototype\" (like MS-office) or a document type (like pptx):\n\n    privateData.type = {};\n    /**\n     * Combine the given options and the default values.\n     * <br /><br />\n     * \n     * This function creating the real options object.\n     * \n     * @param {object} options The options to configure.\n     */\n\n    function setOptions(object, source) {\n      object = object || {};\n      var objectTypes = {\n        'boolean': false,\n        'function': true,\n        'object': true,\n        'number': false,\n        'string': false,\n        'undefined': false\n      };\n\n      function isObject(value) {\n        return !!(value && objectTypes[typeof value]);\n      }\n\n      function keys(object) {\n        if (!isObject(object)) {\n          return [];\n        }\n\n        return Object.keys(object);\n      }\n\n      var index;\n      var iterable = object;\n      var result = iterable;\n      var args = arguments;\n      var argsIndex = 0;\n      var argsLength = args.length; //loop variables \n\n      var ownIndex = -1;\n      var ownProps = objectTypes[typeof iterable] && keys(iterable);\n      var length = ownProps ? ownProps.length : 0;\n\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n\n        if (iterable && objectTypes[typeof iterable]) {\n          while (++ownIndex < length) {\n            index = ownProps[ownIndex];\n\n            if (typeof result[index] === 'undefined' || result[index] === null) {\n              result[index] = iterable[index];\n            } else if (isObject(result[index]) && isObject(iterable[index])) {\n              result[index] = setOptions(result[index], iterable[index]);\n            } // Endif.\n\n          } // End of while loop.\n\n        } // Endif.\n\n      } // End of while loop.\n\n\n      return result;\n    }\n    /**\n     * Configure this object to generate the given type of document.\n     * <br /><br />\n     * \n     * Called by the document constructor to configure the new document object to the given type.\n     * \n     * @param {string} new_type The type of document to create.\n     */\n\n\n    function setGeneratorType(new_type) {\n      privateData.length = 0;\n      var is_ok = false;\n\n      if (new_type) {\n        for (var cur_type in officegenGlobals.types) {\n          if (cur_type == new_type && officegenGlobals.types[cur_type] && officegenGlobals.types[cur_type].createFunc) {\n            officegenGlobals.types[cur_type].createFunc(genobj, new_type, genobj.options, privateData, officegenGlobals.types[cur_type]);\n            is_ok = true;\n            break;\n          } // Endif.\n\n        } // End of for loop.\n\n\n        if (!is_ok) {\n          // console.error ( '\\nFATAL ERROR: Either unknown or unsupported file type - %s\\n', options.type );\n          genobj.emit('error', 'FATAL ERROR: Invalid file type.');\n        } // Endif.\n\n      } // Endif.\n\n    }\n    /**\n     * API for plugins.\n     * <br /><br />\n     * Officegen plugins can extend officegen to support more document formats.\n     * <br /><br />\n     * Examples how to do it can be found on lib/gendocx.js, lib/genpptx.js and lib/genxlsx.js.\n     * @namespace officegen#private#plugs\n     * @example <caption>Adding a new document type to officegen</caption>\n     * var baseobj = require ( \"officegen\" );\n     *\n     * function makeMyDoc ( officegenObj, typeCodeName, options, officegenObjPlugins, typeInfo ) {\n     * \t// officegenObjPlugins = Plugins access to extend officegenObj.\n     * }\n     *\n     * baseobj.plugins.registerDocType (\n     * \t'mydoctype', // The document type's code name.\n     * \tmakeMyDoc,\n     * \t{},\n     * \tbaseobj.docType.TEXT,\n     * \t\"My Special Document File Format\"\n     * );\n     */\n\n\n    privateData.plugs = {\n      /**\n       * Add a resource to the list of resources to place inside the output zip file.\n       * <br /><br />\n       * \n       * This method adding a resource to the list of resources to place inside the output document ZIP.\n       * <br />\n       * Changed by vtloc in 2014Jan10.\n       * \n       * @param {string} resource_name The name of the resource (path).\n       * @param {string} type_of_res The type of this resource: either 'file', 'buffer', 'stream' or 'officegen' (the last one allow you to put office document inside office document).\n       * @param {object} res_data Optional data to use when creating this resource.\n       * @param {function} res_cb Callback to generate this resource (for 'buffer' mode only).\n       * @param {boolean} is_always Is true if this resource is perment for all the zip of this document type.\n       * @param {boolean} removed_after_used Is true if we need to delete this file after used.\n       * @memberof officegen#private#plugs\n       */\n      intAddAnyResourceToParse: function intAddAnyResourceToParse(resource_name, type_of_res, res_data, res_cb, is_always, removed_after_used) {\n        var newRes = {};\n        newRes.name = resource_name;\n        newRes.type = type_of_res;\n        newRes.data = res_data;\n        newRes.callback = res_cb;\n        newRes.is_perment = is_always; // delete the temporatory resources after used\n        // @author vtloc\n        // @date 2014Jan10\n\n        if (removed_after_used) {\n          newRes.removed_after_used = removed_after_used;\n        } else {\n          newRes.removed_after_used = false;\n        } // Endif.\n\n\n        if (officegenGlobals.settings.verbose) {\n          console.log(\"[officegen] Push new res : \", newRes);\n        } // Endif.\n\n\n        privateData.resources.push(newRes);\n      },\n\n      /**\n       * Any additional plugin API must be placed here.\n       * @memberof officegen#private#plugs\n       */\n      type: {}\n    }; // Public API:\n\n    /**\n     * Generating the output document stream.\n     * <br /><br />\n     * \n     * The user of officegen must call this method after filling all the information about what to put inside \n     * the generated document. This method is creating the output document directly into the given stream object.\n     * \n     * The options parameters properties:\n     * \n     * 'finalize' - callback to be called after finishing to generate the document.\n     * 'error' - callback to be called on error.\n     * \n     * @param {object} output_stream The stream to receive the generated document.\n     * @param {object} options Way to pass callbacks.\n     * @function generate\n     * @memberof officegen\n     * @instance\n     */\n\n    this.generate = function (output_stream, options) {\n      if (officegenGlobals.settings.verbose) {\n        console.log(\"[officegen] Start generate() : \", {\n          outputType: privateData.features.outputType\n        });\n      }\n\n      if (typeof options == 'object') {\n        if (options.finalize) {\n          genobj.on('finalize', options.finalize);\n        } // Endif.\n\n\n        if (options.error) {\n          genobj.on('error', options.error);\n        } // Endif.\n\n      } // Endif.\n\n\n      if (privateData.features.page_name) {\n        if (privateData.pages.length == 0) {\n          genobj.emit('error', 'ERROR: No ' + privateData.features.page_name + ' been found inside your document.');\n        } // Endif.\n\n      } // Endif.\n      // Allow the type generator to prepare everything:\n\n\n      genobj.emit('beforeGen', privateData);\n      var archive = archiver(privateData.features.outputType == 'zip' ? 'zip' : 'tar');\n      /**\n       * Error handler.\n       * <br /><br />\n       * \n       * This is our error handler method for creating archive.\n       * \n       * @param {string} err The error string.\n       */\n\n      function onArchiveError(err) {\n        genobj.emit('error', err);\n      }\n\n      archive.on('error', onArchiveError);\n\n      if (privateData.features.outputType == 'gzip') {\n        var zlib = require('zlib');\n\n        var gzipper = zlib.createGzip();\n        archive.pipe(gzipper).pipe(output_stream);\n      } else {\n        archive.pipe(output_stream);\n      } // Endif.\n\n      /**\n       * Add the next resource into the zip stream.\n       * <br /><br />\n       * \n       * This function adding the next resource into the zip stream.\n       */\n\n\n      function generateNextResource(cur_index) {\n        if (officegenGlobals.settings.verbose) {\n          console.log(\"[officegen] generateNextResource(\" + cur_index + \") : \", privateData.resources[cur_index]);\n        }\n\n        var resStream;\n\n        if (cur_index < privateData.resources.length) {\n          if (typeof privateData.resources[cur_index] != 'undefined') {\n            switch (privateData.resources[cur_index].type) {\n              // Generate the resource text data by calling to provided function:\n              case 'buffer':\n                resStream = privateData.resources[cur_index].callback(privateData.resources[cur_index].data);\n                break;\n              // Just copy the file as is:\n\n              case 'file':\n                resStream = fs.createReadStream(privateData.resources[cur_index].data || privateData.resources[cur_index].name);\n                break;\n              // Just use this stream:\n\n              case 'stream':\n                resStream = privateData.resources[cur_index].data;\n                break;\n              // Officegen object:\n\n              case 'officegen':\n                resStream = new PassThrough();\n                privateData.resources[cur_index].data.generate(resStream);\n                break;\n              // Custom parser:\n\n              default:\n                for (var cur_parserType in officegenGlobals.resParserTypes) {\n                  if (cur_parserType == privateData.resources[cur_index].type && officegenGlobals.resParserTypes[cur_parserType] && officegenGlobals.resParserTypes[cur_parserType].parserFunc) {\n                    resStream = officegenGlobals.resParserTypes[cur_parserType].parserFunc(genobj, privateData.resources[cur_index].name, privateData.resources[cur_index].callback, // Can be used as the template source for template engines.\n                    privateData.resources[cur_index].data, // The data for the template engine.\n                    officegenGlobals.resParserTypes[cur_parserType].extra_data);\n                    break;\n                  } // Endif.\n\n                }\n\n              // End of for loop.\n            } // End of switch.\n\n\n            if (typeof resStream != 'undefined') {\n              if (officegenGlobals.settings.verbose) {\n                console.log('[officegen] Adding into archive : \"' + privateData.resources[cur_index].name + '\" (' + privateData.resources[cur_index].type + ')...');\n              } // Endif.\n\n\n              archive.append(resStream, {\n                name: privateData.resources[cur_index].name\n              });\n              generateNextResource(cur_index + 1);\n            } else {\n              if (officegenGlobals.settings.verbose) {\n                console.log(\"[officegen] resStream is undefined\"); // is it normal ??\n              }\n\n              generateNextResource(cur_index + 1); // setImmediate ( function() { generateNextResource ( cur_index + 1 ); });\n            } // Endif.\n\n          } else {\n            // Removed resource - just ignore it:\n            generateNextResource(cur_index + 1); // setImmediate ( function() { generateNextResource ( cur_index + 1 ); });\n          } // Endif.\n\n        } else {\n          // now we can remove all temporary resources\n          privateData.resources.forEach(function (resource) {\n            if (resource.removed_after_used) {\n              var filename = resource.data || resource.name;\n\n              if (officegenGlobals.settings.verbose) {\n                console.log(\"[officegen] Removing resource: \", filename);\n              }\n\n              fs.unlinkSync(filename);\n            }\n          }); // No more resources to add - close the archive:\n\n          if (officegenGlobals.settings.verbose) {\n            console.log(\"[officegen] Finalizing archive ...\");\n          }\n\n          archive.finalize(); // Event to the type generator:\n\n          genobj.emit('afterGen', privateData, null, archive.pointer());\n          genobj.emit('finalize', archive.pointer());\n        } // Endif.\n\n      } // Start the process of generating the output zip stream:\n\n\n      generateNextResource(0);\n    };\n    /**\n     * Reuse this object for a new document of the same type.\n     * <br /><br />\n     * \n     * Call this method if you want to start generating a new document of the same type using this object.\n     * @function startNewDoc\n     * @memberof officegen\n     * @instance\n     */\n\n\n    this.startNewDoc = function () {\n      var kill = [];\n\n      for (var i = 0; i < privateData.resources.length; i++) {\n        if (!privateData.resources[i].is_perment) kill.push(i);\n      } // End of for loop.\n\n\n      for (var i = 0; i < kill.length; i++) {\n        privateData.resources.splice(kill[i] - i, 1);\n      }\n\n      privateData.pages.length = 0;\n      genobj.emit('clearDoc', privateData);\n    }; // Public API - plugin API:\n\n    /**\n     * Register a new resource to add into the generated ZIP stream.\n     * <br /><br />\n     * \n     * Using this method the user can add extra custom resources into the generated ZIP stream.\n     * \n     * @param {string} resource_name The name of the resource (path).\n     * @param {string} type_of_res The type of this resource: either 'file' or 'buffer'.\n     * @param {object} res_data Optional data to use when creating this resource.\n     * @param {function} res_cb Callback to generate this resource (for 'buffer' mode only).\n     * @function addResourceToParse\n     * @memberof officegen\n     * @instance\n     */\n\n\n    this.addResourceToParse = function (resource_name, type_of_res, res_data, res_cb) {\n      // We don't want the user to add permanent resources to the list of resources:\n      privateData.plugs.intAddAnyResourceToParse(resource_name, type_of_res, res_data, res_cb, false);\n    };\n\n    if (typeof options == 'string') {\n      options = {\n        'type': options\n      };\n    } // Endif.\n    // See the officegen descriptions for the rules of the options:\n\n\n    genobj.options = setOptions(options, {\n      'type': 'unknown'\n    });\n\n    if (genobj.options && genobj.options.onerr) {\n      genobj.on('error', genobj.options.onerr);\n    } // Endif.\n\n\n    if (genobj.options && genobj.options.onend) {\n      genobj.on('finalize', genobj.options.onend);\n    } // Endif.\n    // Configure this object depending on the user's selected type:\n\n\n    if (genobj.options.type) {\n      setGeneratorType(genobj.options.type);\n    } // Endif.\n\n\n    return this;\n  };\n\n  sys.inherits(officegen, events.EventEmitter);\n  /**\n   * Create a new officegen object.\n   * <br /><br />\n   * \n   * This method creating a new officegen based object.\n   */\n\n  module.exports = function (options) {\n    return new officegen(options);\n  };\n  /**\n   * Change the verbose state of officegen.\n   * <br /><br />\n   * \n   * This is a global settings effecting all the officegen objects in your application. You should \n   * use it only for debugging.\n   * \n   * @param {boolean} new_state Either true or false.\n   */\n\n\n  module.exports.setVerboseMode = function setVerboseMode(new_state) {\n    officegenGlobals.settings.verbose = new_state;\n  };\n  /**\n   * Plugin API effecting all the instances of the officegen object.\n   *\n   * @namespace officegen#plugins\n   */\n\n\n  var plugins = {\n    /**\n     * Register a new type of document that we can generate.\n     * <br /><br />\n     * \n     * This method registering a new type of document that we can generate. You can extend officegen to support any \n     * type of document that based on resources files inside ZIP stream.\n     * \n     * @param {string} typeName The type of the document file.\n     * @param {function} createFunc The function to use to create this type of file.\n     * @param {object} schema_data Information needed by Schema-API to generate this kind of document.\n     * @param {string} docType Document type.\n     * @param {string} displayName The display name of this type.\n     * @memberof officegen#plugins\n     */\n    registerDocType: function registerDocType(typeName, createFunc, schema_data, docType, displayName) {\n      officegenGlobals.types[typeName] = {};\n      officegenGlobals.types[typeName].createFunc = createFunc;\n      officegenGlobals.types[typeName].schema_data = schema_data;\n      officegenGlobals.types[typeName].type = docType;\n      officegenGlobals.types[typeName].display = displayName;\n    },\n\n    /**\n     * Get a document type object by name.\n     * <br /><br />\n     * \n     * This method get a document type object.\n     * \n     * @param {string} typeName The name of the document type.\n     * @return The plugin object of the document type.\n     * @memberof officegen#plugins\n     */\n    getDocTypeByName: function getDocTypeByName(typeName) {\n      return officegenGlobals.types[typeName];\n    },\n\n    /**\n     * Register a document prototype object.\n     * <br /><br />\n     * \n     * This method registering a prototype document object. You can place all the common code needed by a group of document \n     * types in a single prototype object.\n     * \n     * @param {string} typeName The name of the prototype object.\n     * @param {object} baseObj The prototype object.\n     * @param {string} displayName The display name of this type.\n     * @memberof officegen#plugins\n     */\n    registerPrototype: function registerPrototype(typeName, baseObj, displayName) {\n      officegenGlobals.docPrototypes[typeName] = {};\n      officegenGlobals.docPrototypes[typeName].baseObj = baseObj;\n      officegenGlobals.docPrototypes[typeName].display = displayName;\n    },\n\n    /**\n     * Get a document prototype object by name.\n     * <br /><br />\n     * \n     * This method get a prototype object.\n     * \n     * @param {string} typeName The name of the prototype object.\n     * @return The prototype plugin object.\n     * @memberof officegen#plugins\n     */\n    getPrototypeByName: function getPrototypeByName(typeName) {\n      return officegenGlobals.docPrototypes[typeName];\n    },\n\n    /**\n     * Register a new resource parser.\n     * <br /><br />\n     * \n     * This method registering a new resource parser. One use of this feature is in case that you are developing a new \n     * type of document and you want to extend officegen to use some kind of template engine as jade, ejs, haml* or CoffeeKup. \n     * In this case you can use a template engine to generate one or more of the resources inside the output archive. \n     * Another use of this method is to replace an existing plugin with different implementation.\n     * \n     * @param {string} typeName The type of the parser plugin.\n     * @param {function} parserFunc The resource generating function.\n     * @param {object} extra_data Optional additional data that may be required by the parser function.\n     * @param {string} displayName The display name of this type.\n     * @memberof officegen#plugins\n     */\n    registerParserType: function registerParserType(typeName, parserFunc, extra_data, displayName) {\n      officegenGlobals.resParserTypes[typeName] = {};\n      officegenGlobals.resParserTypes[typeName].parserFunc = parserFunc;\n      officegenGlobals.resParserTypes[typeName].extra_data = extra_data;\n      officegenGlobals.resParserTypes[typeName].display = displayName;\n    },\n\n    /**\n     * Get if we need verbose mode.\n     * @param {string} docType Optional, Allow filtering by document type.\n     * @param {string} moduleName Optional, Allow filtering by feature / module.\n     * @memberof officegen#plugins\n     */\n    getVerboseMode: function getVerboseMode(docType, moduleName) {\n      if (!docType && !moduleName) {\n        return officegenGlobals.settings.verbose ? true : false;\n      } // Endif.\n\n\n      var verboseFlag;\n\n      if (officegenGlobals.settings.verbose && typeof officegenGlobals.settings.verbose === 'object') {\n        if (docType && officegenGlobals.settings.verbose.docType && typeof officegenGlobals.settings.verbose.docType === 'object' && officegenGlobals.settings.verbose.docType.indexOf) {\n          verboseFlag = officegenGlobals.settings.verbose.docType.indexOf(docType) >= 0 ? true : false;\n        } // Endif.\n\n\n        if (verboseFlag !== false && moduleName && officegenGlobals.settings.verbose.moduleName && typeof officegenGlobals.settings.verbose.moduleName === 'object' && officegenGlobals.settings.verbose.moduleName.indexOf) {\n          verboseFlag = officegenGlobals.settings.verbose.moduleName.indexOf(moduleName) >= 0 ? true : false;\n        } // Endif.\n\n      } // Endif.\n\n\n      return verboseFlag ? true : false;\n    }\n  };\n  module.exports.plugins = plugins;\n  module.exports.schema = officegenGlobals.types;\n  module.exports.docType = {\n    \"TEXT\": 1,\n    \"SPREADSHEET\": 2,\n    \"PRESENTATION\": 3\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}