{"ast":null,"code":"'use strict';\n\nvar childProcess = require('child_process');\n\nvar util = require('util');\n\nvar crossSpawn = require('cross-spawn');\n\nvar stripEof = require('strip-eof');\n\nvar npmRunPath = require('npm-run-path');\n\nvar isStream = require('is-stream');\n\nvar _getStream = require('get-stream');\n\nvar pFinally = require('p-finally');\n\nvar onExit = require('signal-exit');\n\nvar errname = require('./lib/errname');\n\nvar stdio = require('./lib/stdio');\n\nvar TEN_MEGABYTES = 1000 * 1000 * 10;\n\nfunction handleArgs(cmd, args, opts) {\n  var parsed;\n  opts = Object.assign({\n    extendEnv: true,\n    env: {}\n  }, opts);\n\n  if (opts.extendEnv) {\n    opts.env = Object.assign({}, process.env, opts.env);\n  }\n\n  if (opts.__winShell === true) {\n    delete opts.__winShell;\n    parsed = {\n      command: cmd,\n      args: args,\n      options: opts,\n      file: cmd,\n      original: cmd\n    };\n  } else {\n    parsed = crossSpawn._parse(cmd, args, opts);\n  }\n\n  opts = Object.assign({\n    maxBuffer: TEN_MEGABYTES,\n    stripEof: true,\n    preferLocal: true,\n    localDir: parsed.options.cwd || process.cwd(),\n    encoding: 'utf8',\n    reject: true,\n    cleanup: true\n  }, parsed.options);\n  opts.stdio = stdio(opts);\n\n  if (opts.preferLocal) {\n    opts.env = npmRunPath.env(Object.assign({}, opts, {\n      cwd: opts.localDir\n    }));\n  }\n\n  return {\n    cmd: parsed.command,\n    args: parsed.args,\n    opts: opts,\n    parsed: parsed\n  };\n}\n\nfunction handleInput(spawned, opts) {\n  var input = opts.input;\n\n  if (input === null || input === undefined) {\n    return;\n  }\n\n  if (isStream(input)) {\n    input.pipe(spawned.stdin);\n  } else {\n    spawned.stdin.end(input);\n  }\n}\n\nfunction handleOutput(opts, val) {\n  if (val && opts.stripEof) {\n    val = stripEof(val);\n  }\n\n  return val;\n}\n\nfunction handleShell(fn, cmd, opts) {\n  var file = '/bin/sh';\n  var args = ['-c', cmd];\n  opts = Object.assign({}, opts);\n\n  if (process.platform === 'win32') {\n    opts.__winShell = true;\n    file = process.env.comspec || 'cmd.exe';\n    args = ['/s', '/c', \"\\\"\".concat(cmd, \"\\\"\")];\n    opts.windowsVerbatimArguments = true;\n  }\n\n  if (opts.shell) {\n    file = opts.shell;\n    delete opts.shell;\n  }\n\n  return fn(file, args, opts);\n}\n\nfunction getStream(process, stream, encoding, maxBuffer) {\n  if (!process[stream]) {\n    return null;\n  }\n\n  var ret;\n\n  if (encoding) {\n    ret = _getStream(process[stream], {\n      encoding: encoding,\n      maxBuffer: maxBuffer\n    });\n  } else {\n    ret = _getStream.buffer(process[stream], {\n      maxBuffer: maxBuffer\n    });\n  }\n\n  return ret.catch(function (err) {\n    err.stream = stream;\n    err.message = \"\".concat(stream, \" \").concat(err.message);\n    throw err;\n  });\n}\n\nmodule.exports = function (cmd, args, opts) {\n  var joinedCmd = cmd;\n\n  if (Array.isArray(args) && args.length > 0) {\n    joinedCmd += ' ' + args.join(' ');\n  }\n\n  var parsed = handleArgs(cmd, args, opts);\n  var encoding = parsed.opts.encoding;\n  var maxBuffer = parsed.opts.maxBuffer;\n  var spawned;\n\n  try {\n    spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  var removeExitHandler;\n\n  if (parsed.opts.cleanup) {\n    removeExitHandler = onExit(function () {\n      spawned.kill();\n    });\n  }\n\n  var timeoutId = null;\n  var timedOut = false;\n\n  var cleanupTimeout = function cleanupTimeout() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  if (parsed.opts.timeout > 0) {\n    timeoutId = setTimeout(function () {\n      timeoutId = null;\n      timedOut = true;\n      spawned.kill(parsed.opts.killSignal);\n    }, parsed.opts.timeout);\n  }\n\n  var processDone = new Promise(function (resolve) {\n    spawned.on('exit', function (code, signal) {\n      cleanupTimeout();\n      resolve({\n        code: code,\n        signal: signal\n      });\n    });\n    spawned.on('error', function (err) {\n      cleanupTimeout();\n      resolve({\n        err: err\n      });\n    });\n\n    if (spawned.stdin) {\n      spawned.stdin.on('error', function (err) {\n        cleanupTimeout();\n        resolve({\n          err: err\n        });\n      });\n    }\n  });\n\n  function destroy() {\n    if (spawned.stdout) {\n      spawned.stdout.destroy();\n    }\n\n    if (spawned.stderr) {\n      spawned.stderr.destroy();\n    }\n  }\n\n  var handlePromise = function handlePromise() {\n    return pFinally(Promise.all([processDone, getStream(spawned, 'stdout', encoding, maxBuffer), getStream(spawned, 'stderr', encoding, maxBuffer)]).then(function (arr) {\n      var result = arr[0];\n      var stdout = arr[1];\n      var stderr = arr[2];\n      var err = result.err;\n      var code = result.code;\n      var signal = result.signal;\n\n      if (removeExitHandler) {\n        removeExitHandler();\n      }\n\n      if (err || code !== 0 || signal !== null) {\n        if (!err) {\n          var output = '';\n\n          if (Array.isArray(parsed.opts.stdio)) {\n            if (parsed.opts.stdio[2] !== 'inherit') {\n              output += output.length > 0 ? stderr : \"\\n\".concat(stderr);\n            }\n\n            if (parsed.opts.stdio[1] !== 'inherit') {\n              output += \"\\n\".concat(stdout);\n            }\n          } else if (parsed.opts.stdio !== 'inherit') {\n            output = \"\\n\".concat(stderr).concat(stdout);\n          }\n\n          err = new Error(\"Command failed: \".concat(joinedCmd).concat(output));\n          err.code = code < 0 ? errname(code) : code;\n        } // TODO: missing some timeout logic for killed\n        // https://github.com/nodejs/node/blob/master/lib/child_process.js#L203\n        // err.killed = spawned.killed || killed;\n\n\n        err.killed = err.killed || spawned.killed;\n        err.stdout = stdout;\n        err.stderr = stderr;\n        err.failed = true;\n        err.signal = signal || null;\n        err.cmd = joinedCmd;\n        err.timedOut = timedOut;\n\n        if (!parsed.opts.reject) {\n          return err;\n        }\n\n        throw err;\n      }\n\n      return {\n        stdout: handleOutput(parsed.opts, stdout),\n        stderr: handleOutput(parsed.opts, stderr),\n        code: 0,\n        failed: false,\n        killed: false,\n        signal: null,\n        cmd: joinedCmd,\n        timedOut: false\n      };\n    }), destroy);\n  };\n\n  crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);\n\n  handleInput(spawned, parsed.opts);\n\n  spawned.then = function (onfulfilled, onrejected) {\n    return handlePromise().then(onfulfilled, onrejected);\n  };\n\n  spawned.catch = function (onrejected) {\n    return handlePromise().catch(onrejected);\n  };\n\n  return spawned;\n};\n\nmodule.exports.stdout = function () {\n  // TODO: set `stderr: 'ignore'` when that option is implemented\n  return module.exports.apply(null, arguments).then(function (x) {\n    return x.stdout;\n  });\n};\n\nmodule.exports.stderr = function () {\n  // TODO: set `stdout: 'ignore'` when that option is implemented\n  return module.exports.apply(null, arguments).then(function (x) {\n    return x.stderr;\n  });\n};\n\nmodule.exports.shell = function (cmd, opts) {\n  return handleShell(module.exports, cmd, opts);\n};\n\nmodule.exports.sync = function (cmd, args, opts) {\n  var parsed = handleArgs(cmd, args, opts);\n\n  if (isStream(parsed.opts.input)) {\n    throw new TypeError('The `input` option cannot be a stream in sync mode');\n  }\n\n  var result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);\n\n  if (result.error || result.status !== 0) {\n    throw result.error || new Error(result.stderr === '' ? result.stdout : result.stderr);\n  }\n\n  result.stdout = handleOutput(parsed.opts, result.stdout);\n  result.stderr = handleOutput(parsed.opts, result.stderr);\n  return result;\n};\n\nmodule.exports.shellSync = function (cmd, opts) {\n  return handleShell(module.exports.sync, cmd, opts);\n};\n\nmodule.exports.spawn = util.deprecate(module.exports, 'execa.spawn() is deprecated. Use execa() instead.');","map":null,"metadata":{},"sourceType":"script"}