{"ast":null,"code":"'use strict';\n\nvar resolveCommand = require('./util/resolveCommand');\n\nvar hasEmptyArgumentBug = require('./util/hasEmptyArgumentBug');\n\nvar escapeArgument = require('./util/escapeArgument');\n\nvar escapeCommand = require('./util/escapeCommand');\n\nvar readShebang = require('./util/readShebang');\n\nvar isWin = process.platform === 'win32';\nvar skipShellRegExp = /\\.(?:com|exe)$/i; // Supported in Node >= 6 and >= 4.8\n\nvar supportsShellOption = parseInt(process.version.substr(1).split('.')[0], 10) >= 6 || parseInt(process.version.substr(1).split('.')[0], 10) === 4 && parseInt(process.version.substr(1).split('.')[1], 10) >= 8;\n\nfunction parseNonShell(parsed) {\n  var shebang;\n  var needsShell;\n  var applyQuotes;\n\n  if (!isWin) {\n    return parsed;\n  } // Detect & add support for shebangs\n\n\n  parsed.file = resolveCommand(parsed.command);\n  parsed.file = parsed.file || resolveCommand(parsed.command, true);\n  shebang = parsed.file && readShebang(parsed.file);\n\n  if (shebang) {\n    parsed.args.unshift(parsed.file);\n    parsed.command = shebang;\n    needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(resolveCommand(shebang) || resolveCommand(shebang, true));\n  } else {\n    needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(parsed.file);\n  } // If a shell is required, use cmd.exe and take care of escaping everything correctly\n\n\n  if (needsShell) {\n    // Escape command & arguments\n    applyQuotes = parsed.command !== 'echo'; // Do not quote arguments for the special \"echo\" command\n\n    parsed.command = escapeCommand(parsed.command);\n    parsed.args = parsed.args.map(function (arg) {\n      return escapeArgument(arg, applyQuotes);\n    }); // Make use of cmd.exe\n\n    parsed.args = ['/d', '/s', '/c', '\"' + parsed.command + (parsed.args.length ? ' ' + parsed.args.join(' ') : '') + '\"'];\n    parsed.command = process.env.comspec || 'cmd.exe';\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  }\n\n  return parsed;\n}\n\nfunction parseShell(parsed) {\n  var shellCommand; // If node supports the shell option, there's no need to mimic its behavior\n\n  if (supportsShellOption) {\n    return parsed;\n  } // Mimic node shell option, see: https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n\n\n  shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n  if (isWin) {\n    parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n    parsed.args = ['/d', '/s', '/c', '\"' + shellCommand + '\"'];\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  } else {\n    if (typeof parsed.options.shell === 'string') {\n      parsed.command = parsed.options.shell;\n    } else if (process.platform === 'android') {\n      parsed.command = '/system/bin/sh';\n    } else {\n      parsed.command = '/bin/sh';\n    }\n\n    parsed.args = ['-c', shellCommand];\n  }\n\n  return parsed;\n} // ------------------------------------------------\n\n\nfunction parse(command, args, options) {\n  var parsed; // Normalize arguments, similar to nodejs\n\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n\n  options = options || {}; // Build our parsed object\n\n  parsed = {\n    command: command,\n    args: args,\n    options: options,\n    file: undefined,\n    original: command\n  }; // Delegate further parsing to shell or non-shell\n\n  return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\n\nmodule.exports = parse;","map":null,"metadata":{},"sourceType":"script"}