{"ast":null,"code":"//------------------------------------------------------------------\n// Dependencies\nvar Stream = require('readable-stream'),\n    util = require('util'); //------------------------------------------------------------------\n// Exports\n\n\nmodule.exports = WritableStream; //------------------------------------------------------------------\n// WritableStream class\n\nutil.inherits(WritableStream, Stream.Writable);\n\nfunction WritableStream(options) {\n  Stream.Writable.call(this, options);\n}\n\nWritableStream.prototype.write = function (chunk, encoding, callback) {\n  var ret = Stream.Writable.prototype.write.apply(this, arguments);\n  if (!ret) this.emit('drain');\n  return ret;\n};\n\nWritableStream.prototype._write = function (chunk, encoding, callback) {\n  this.write(chunk, encoding, callback);\n};\n\nWritableStream.prototype.toString = function () {\n  return this.toBuffer().toString();\n};\n\nWritableStream.prototype.toBuffer = function () {\n  var buffers = [];\n\n  this._writableState.buffer.forEach(function (data) {\n    buffers.push(data.chunk);\n  });\n\n  return Buffer.concat(buffers);\n};\n\nWritableStream.prototype.end = function (chunk, encoding, callback) {\n  var ret = Stream.Writable.prototype.end.apply(this, arguments); // In memory stream doesn't need to flush anything so emit `finish` right away\n  // base implementation in Stream.Writable doesn't emit finish\n\n  this.emit('finish');\n  return ret;\n};","map":null,"metadata":{},"sourceType":"script"}