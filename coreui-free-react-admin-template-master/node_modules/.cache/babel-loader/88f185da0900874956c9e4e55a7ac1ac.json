{"ast":null,"code":"/** @license React v16.1.0-beta\n * react-reconciler.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  var $$$reconciler;\n\n  module.exports = function (config) {\n    'use strict';\n\n    var invariant = require('fbjs/lib/invariant');\n\n    var warning = require('fbjs/lib/warning');\n\n    var React = require('react');\n\n    var emptyObject = require('fbjs/lib/emptyObject');\n\n    var _assign = require('object-assign');\n\n    var checkPropTypes = require('prop-types/checkPropTypes');\n\n    var shallowEqual = require('fbjs/lib/shallowEqual');\n\n    var ReactFeatureFlags = {\n      enableAsyncSubtreeAPI: true,\n      enableAsyncSchedulingByDefaultInReactDOM: false,\n      // Mutating mode (React DOM, React ART, React Native):\n      enableMutatingReconciler: true,\n      // Experimental noop mode (currently unused):\n      enableNoopReconciler: false,\n      // Experimental persistent mode (CS):\n      enablePersistentReconciler: false,\n      // Exports React.Fragment\n      enableReactFragment: false,\n      // Exports ReactDOM.createRoot\n      enableCreateRoot: false\n    };\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    {\n      if (Object.freeze) {\n        Object.freeze(ReactFeatureFlags);\n      }\n    }\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    /**\n     * WARNING: DO NOT manually require this module.\n     * This is a replacement for `invariant(...)` used by the error code system\n     * and will _only_ be required by the corresponding babel pass.\n     * It always throws.\n     */\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     */\n\n    /**\n     * `ReactInstanceMap` maintains a mapping from a public facing stateful\n     * instance (key) and the internal representation (value). This allows public\n     * methods to accept the user facing instance as an argument and map them back\n     * to internal methods.\n     *\n     * Note that this module is currently shared and assumed to be stateless.\n     * If this becomes an actual Map, that will break.\n     */\n\n    /**\n       * This API should be called `delete` but we'd have to make sure to always\n       * transform these to strings for IE support. When this transform is fully\n       * supported we can rename it.\n       */\n\n    function get(key) {\n      return key._reactInternalFiber;\n    }\n\n    function set(key, value) {\n      key._reactInternalFiber = value;\n    }\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     */\n\n\n    var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\n    function getComponentName(fiber) {\n      var type = fiber.type;\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name;\n      }\n\n      return null;\n    }\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var IndeterminateComponent = 0; // Before we know whether it is functional or class\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var FunctionalComponent = 1;\n    var ClassComponent = 2;\n    var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n\n    var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n\n    var HostComponent = 5;\n    var HostText = 6;\n    var CallComponent = 7;\n    var CallHandlerPhase = 8;\n    var ReturnComponent = 9;\n    var Fragment = 10; // Don't change these two values:\n\n    var NoEffect = 0; //           0b00000000\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var PerformedWork = 1; //      0b00000001\n    // You can change the rest (and add more).\n\n    var Placement = 2; //          0b00000010\n\n    var Update = 4; //             0b00000100\n\n    var PlacementAndUpdate = 6; // 0b00000110\n\n    var Deletion = 8; //           0b00001000\n\n    var ContentReset = 16; //      0b00010000\n\n    var Callback = 32; //          0b00100000\n\n    var Err = 64; //               0b01000000\n\n    var Ref = 128; //              0b10000000\n\n    var MOUNTING = 1;\n    var MOUNTED = 2;\n    var UNMOUNTED = 3;\n\n    function isFiberMountedImpl(fiber) {\n      var node = fiber;\n\n      if (!fiber.alternate) {\n        // If there is no alternate, this might be a new tree that isn't inserted\n        // yet. If it is, then it will have a pending insertion effect on it.\n        if ((node.effectTag & Placement) !== NoEffect) {\n          return MOUNTING;\n        }\n\n        while (node['return']) {\n          node = node['return'];\n\n          if ((node.effectTag & Placement) !== NoEffect) {\n            return MOUNTING;\n          }\n        }\n      } else {\n        while (node['return']) {\n          node = node['return'];\n        }\n      }\n\n      if (node.tag === HostRoot) {\n        // TODO: Check if this was a nested HostRoot when used with\n        // renderContainerIntoSubtree.\n        return MOUNTED;\n      } // If we didn't hit the root, that means that we're in an disconnected tree\n      // that has been unmounted.\n\n\n      return UNMOUNTED;\n    }\n\n    function isFiberMounted(fiber) {\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    }\n\n    function isMounted(component) {\n      {\n        var owner = ReactCurrentOwner.current;\n\n        if (owner !== null && owner.tag === ClassComponent) {\n          var ownerFiber = owner;\n          var instance = ownerFiber.stateNode;\n          warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');\n          instance._warnedAboutRefsInRender = true;\n        }\n      }\n      var fiber = get(component);\n\n      if (!fiber) {\n        return false;\n      }\n\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    }\n\n    function assertIsMounted(fiber) {\n      !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    }\n\n    function findCurrentFiberUsingSlowPath(fiber) {\n      var alternate = fiber.alternate;\n\n      if (!alternate) {\n        // If there is no alternate, then we only need to check if it is mounted.\n        var state = isFiberMountedImpl(fiber);\n        !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n\n        if (state === MOUNTING) {\n          return null;\n        }\n\n        return fiber;\n      } // If we have two possible branches, we'll walk backwards up to the root\n      // to see what path the root points to. On the way we may hit one of the\n      // special cases and we'll deal with them.\n\n\n      var a = fiber;\n      var b = alternate;\n\n      while (true) {\n        var parentA = a['return'];\n        var parentB = parentA ? parentA.alternate : null;\n\n        if (!parentA || !parentB) {\n          // We're at the root.\n          break;\n        } // If both copies of the parent fiber point to the same child, we can\n        // assume that the child is current. This happens when we bailout on low\n        // priority: the bailed out fiber's child reuses the current child.\n\n\n        if (parentA.child === parentB.child) {\n          var child = parentA.child;\n\n          while (child) {\n            if (child === a) {\n              // We've determined that A is the current branch.\n              assertIsMounted(parentA);\n              return fiber;\n            }\n\n            if (child === b) {\n              // We've determined that B is the current branch.\n              assertIsMounted(parentA);\n              return alternate;\n            }\n\n            child = child.sibling;\n          } // We should never have an alternate for any mounting node. So the only\n          // way this could possibly happen is if this was unmounted, if at all.\n\n\n          invariant(false, 'Unable to find node on an unmounted component.');\n        }\n\n        if (a['return'] !== b['return']) {\n          // The return pointer of A and the return pointer of B point to different\n          // fibers. We assume that return pointers never criss-cross, so A must\n          // belong to the child set of A.return, and B must belong to the child\n          // set of B.return.\n          a = parentA;\n          b = parentB;\n        } else {\n          // The return pointers point to the same fiber. We'll have to use the\n          // default, slow path: scan the child sets of each parent alternate to see\n          // which child belongs to which set.\n          //\n          // Search parent A's child set\n          var didFindChild = false;\n          var _child = parentA.child;\n\n          while (_child) {\n            if (_child === a) {\n              didFindChild = true;\n              a = parentA;\n              b = parentB;\n              break;\n            }\n\n            if (_child === b) {\n              didFindChild = true;\n              b = parentA;\n              a = parentB;\n              break;\n            }\n\n            _child = _child.sibling;\n          }\n\n          if (!didFindChild) {\n            // Search parent B's child set\n            _child = parentB.child;\n\n            while (_child) {\n              if (_child === a) {\n                didFindChild = true;\n                a = parentB;\n                b = parentA;\n                break;\n              }\n\n              if (_child === b) {\n                didFindChild = true;\n                b = parentB;\n                a = parentA;\n                break;\n              }\n\n              _child = _child.sibling;\n            }\n\n            !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n          }\n        }\n\n        !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      } // If the root is not a host container, we're in a disconnected tree. I.e.\n      // unmounted.\n\n\n      !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n\n      if (a.stateNode.current === a) {\n        // We've determined that A is the current branch.\n        return fiber;\n      } // Otherwise B has to be current branch.\n\n\n      return alternate;\n    }\n\n    function findCurrentHostFiber(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n\n      if (!currentParent) {\n        return null;\n      } // Next we'll drill down this component to find the first HostComponent/Text.\n\n\n      var node = currentParent;\n\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        } else if (node.child) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === currentParent) {\n          return null;\n        }\n\n        while (!node.sibling) {\n          if (!node['return'] || node['return'] === currentParent) {\n            return null;\n          }\n\n          node = node['return'];\n        }\n\n        node.sibling['return'] = node['return'];\n        node = node.sibling;\n      } // Flow needs the return null here, but ESLint complains about it.\n      // eslint-disable-next-line no-unreachable\n\n\n      return null;\n    }\n\n    function findCurrentHostFiberWithNoPortals(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n\n      if (!currentParent) {\n        return null;\n      } // Next we'll drill down this component to find the first HostComponent/Text.\n\n\n      var node = currentParent;\n\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        } else if (node.child && node.tag !== HostPortal) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === currentParent) {\n          return null;\n        }\n\n        while (!node.sibling) {\n          if (!node['return'] || node['return'] === currentParent) {\n            return null;\n          }\n\n          node = node['return'];\n        }\n\n        node.sibling['return'] = node['return'];\n        node = node.sibling;\n      } // Flow needs the return null here, but ESLint complains about it.\n      // eslint-disable-next-line no-unreachable\n\n\n      return null;\n    }\n\n    var valueStack = [];\n    {\n      var fiberStack = [];\n    }\n    var index = -1;\n\n    function createCursor(defaultValue) {\n      return {\n        current: defaultValue\n      };\n    }\n\n    function pop(cursor, fiber) {\n      if (index < 0) {\n        {\n          warning(false, 'Unexpected pop.');\n        }\n        return;\n      }\n\n      {\n        if (fiber !== fiberStack[index]) {\n          warning(false, 'Unexpected Fiber popped.');\n        }\n      }\n      cursor.current = valueStack[index];\n      valueStack[index] = null;\n      {\n        fiberStack[index] = null;\n      }\n      index--;\n    }\n\n    function push(cursor, value, fiber) {\n      index++;\n      valueStack[index] = cursor.current;\n      {\n        fiberStack[index] = fiber;\n      }\n      cursor.current = value;\n    }\n\n    function reset() {\n      while (index > -1) {\n        valueStack[index] = null;\n        {\n          fiberStack[index] = null;\n        }\n        index--;\n      }\n    }\n    /**\n     * Copyright (c) 2016-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {\n      return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n    };\n\n    function describeFiber(fiber) {\n      switch (fiber.tag) {\n        case IndeterminateComponent:\n        case FunctionalComponent:\n        case ClassComponent:\n        case HostComponent:\n          var owner = fiber._debugOwner;\n          var source = fiber._debugSource;\n          var name = getComponentName(fiber);\n          var ownerName = null;\n\n          if (owner) {\n            ownerName = getComponentName(owner);\n          }\n\n          return describeComponentFrame(name, source, ownerName);\n\n        default:\n          return '';\n      }\n    } // This function can only be called with a work-in-progress fiber and\n    // only during begin or complete phase. Do not call it under any other\n    // circumstances.\n\n\n    function getStackAddendumByWorkInProgressFiber(workInProgress) {\n      var info = '';\n      var node = workInProgress;\n\n      do {\n        info += describeFiber(node); // Otherwise this return pointer might point to the wrong tree:\n\n        node = node['return'];\n      } while (node);\n\n      return info;\n    }\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    function getCurrentFiberOwnerName() {\n      {\n        var fiber = ReactDebugCurrentFiber.current;\n\n        if (fiber === null) {\n          return null;\n        }\n\n        var owner = fiber._debugOwner;\n\n        if (owner !== null && typeof owner !== 'undefined') {\n          return getComponentName(owner);\n        }\n      }\n      return null;\n    }\n\n    function getCurrentFiberStackAddendum() {\n      {\n        var fiber = ReactDebugCurrentFiber.current;\n\n        if (fiber === null) {\n          return null;\n        } // Safe because if current fiber exists, we are reconciling,\n        // and it is guaranteed to be the work-in-progress version.\n\n\n        return getStackAddendumByWorkInProgressFiber(fiber);\n      }\n      return null;\n    }\n\n    function resetCurrentFiber() {\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFiber.current = null;\n      ReactDebugCurrentFiber.phase = null;\n    }\n\n    function setCurrentFiber(fiber) {\n      ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n      ReactDebugCurrentFiber.current = fiber;\n      ReactDebugCurrentFiber.phase = null;\n    }\n\n    function setCurrentPhase(phase) {\n      ReactDebugCurrentFiber.phase = phase;\n    }\n\n    var ReactDebugCurrentFiber = {\n      current: null,\n      phase: null,\n      resetCurrentFiber: resetCurrentFiber,\n      setCurrentFiber: setCurrentFiber,\n      setCurrentPhase: setCurrentPhase,\n      getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n      getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n    }; // Trust the developer to only use this with a true check\n\n    var ReactDebugFiberPerf = {};\n    {\n      // Prefix measurements so that it's possible to filter them.\n      // Longer prefixes are hard to read in DevTools.\n      var reactEmoji = \"\\u269B\";\n      var warningEmoji = \"\\u26D4\";\n      var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function'; // Keep track of current fiber so that we know the path to unwind on pause.\n      // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\n\n      var currentFiber = null; // If we're in the middle of user code, which fiber and method is it?\n      // Reusing `currentFiber` would be confusing for this because user code fiber\n      // can change during commit phase too, but we don't need to unwind it (since\n      // lifecycles in the commit phase don't resemble a tree).\n\n      var currentPhase = null;\n      var currentPhaseFiber = null; // Did lifecycle hook schedule an update? This is often a performance problem,\n      // so we will keep track of it, and include it in the report.\n      // Track commits caused by cascading updates.\n\n      var isCommitting = false;\n      var hasScheduledUpdateInCurrentCommit = false;\n      var hasScheduledUpdateInCurrentPhase = false;\n      var commitCountInCurrentWorkLoop = 0;\n      var effectCountInCurrentCommit = 0; // During commits, we only show a measurement once per method name\n      // to avoid stretch the commit phase with measurement overhead.\n\n      var labelsInCurrentCommit = new Set();\n\n      var formatMarkName = function formatMarkName(markName) {\n        return reactEmoji + ' ' + markName;\n      };\n\n      var formatLabel = function formatLabel(label, warning$$1) {\n        var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n        var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n        return '' + prefix + label + suffix;\n      };\n\n      var beginMark = function beginMark(markName) {\n        performance.mark(formatMarkName(markName));\n      };\n\n      var clearMark = function clearMark(markName) {\n        performance.clearMarks(formatMarkName(markName));\n      };\n\n      var endMark = function endMark(label, markName, warning$$1) {\n        var formattedMarkName = formatMarkName(markName);\n        var formattedLabel = formatLabel(label, warning$$1);\n\n        try {\n          performance.measure(formattedLabel, formattedMarkName);\n        } catch (err) {} // If previous mark was missing for some reason, this will throw.\n        // This could only happen if React crashed in an unexpected place earlier.\n        // Don't pile on with more errors.\n        // Clear marks immediately to avoid growing buffer.\n\n\n        performance.clearMarks(formattedMarkName);\n        performance.clearMeasures(formattedLabel);\n      };\n\n      var getFiberMarkName = function getFiberMarkName(label, debugID) {\n        return label + ' (#' + debugID + ')';\n      };\n\n      var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {\n        if (phase === null) {\n          // These are composite component total time measurements.\n          return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n        } else {\n          // Composite component methods.\n          return componentName + '.' + phase;\n        }\n      };\n\n      var beginFiberMark = function beginFiberMark(fiber, phase) {\n        var componentName = getComponentName(fiber) || 'Unknown';\n        var debugID = fiber._debugID;\n        var isMounted = fiber.alternate !== null;\n        var label = getFiberLabel(componentName, isMounted, phase);\n\n        if (isCommitting && labelsInCurrentCommit.has(label)) {\n          // During the commit phase, we don't show duplicate labels because\n          // there is a fixed overhead for every measurement, and we don't\n          // want to stretch the commit phase beyond necessary.\n          return false;\n        }\n\n        labelsInCurrentCommit.add(label);\n        var markName = getFiberMarkName(label, debugID);\n        beginMark(markName);\n        return true;\n      };\n\n      var clearFiberMark = function clearFiberMark(fiber, phase) {\n        var componentName = getComponentName(fiber) || 'Unknown';\n        var debugID = fiber._debugID;\n        var isMounted = fiber.alternate !== null;\n        var label = getFiberLabel(componentName, isMounted, phase);\n        var markName = getFiberMarkName(label, debugID);\n        clearMark(markName);\n      };\n\n      var endFiberMark = function endFiberMark(fiber, phase, warning$$1) {\n        var componentName = getComponentName(fiber) || 'Unknown';\n        var debugID = fiber._debugID;\n        var isMounted = fiber.alternate !== null;\n        var label = getFiberLabel(componentName, isMounted, phase);\n        var markName = getFiberMarkName(label, debugID);\n        endMark(label, markName, warning$$1);\n      };\n\n      var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {\n        // Host components should be skipped in the timeline.\n        // We could check typeof fiber.type, but does this work with RN?\n        switch (fiber.tag) {\n          case HostRoot:\n          case HostComponent:\n          case HostText:\n          case HostPortal:\n          case ReturnComponent:\n          case Fragment:\n            return true;\n\n          default:\n            return false;\n        }\n      };\n\n      var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {\n        if (currentPhase !== null && currentPhaseFiber !== null) {\n          clearFiberMark(currentPhaseFiber, currentPhase);\n        }\n\n        currentPhaseFiber = null;\n        currentPhase = null;\n        hasScheduledUpdateInCurrentPhase = false;\n      };\n\n      var pauseTimers = function pauseTimers() {\n        // Stops all currently active measurements so that they can be resumed\n        // if we continue in a later deferred loop from the same unit of work.\n        var fiber = currentFiber;\n\n        while (fiber) {\n          if (fiber._debugIsCurrentlyTiming) {\n            endFiberMark(fiber, null, null);\n          }\n\n          fiber = fiber['return'];\n        }\n      };\n\n      var resumeTimersRecursively = function resumeTimersRecursively(fiber) {\n        if (fiber['return'] !== null) {\n          resumeTimersRecursively(fiber['return']);\n        }\n\n        if (fiber._debugIsCurrentlyTiming) {\n          beginFiberMark(fiber, null);\n        }\n      };\n\n      var resumeTimers = function resumeTimers() {\n        // Resumes all measurements that were active during the last deferred loop.\n        if (currentFiber !== null) {\n          resumeTimersRecursively(currentFiber);\n        }\n      };\n\n      ReactDebugFiberPerf = {\n        recordEffect: function recordEffect() {\n          effectCountInCurrentCommit++;\n        },\n        recordScheduleUpdate: function recordScheduleUpdate() {\n          if (isCommitting) {\n            hasScheduledUpdateInCurrentCommit = true;\n          }\n\n          if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n            hasScheduledUpdateInCurrentPhase = true;\n          }\n        },\n        startWorkTimer: function startWorkTimer(fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          } // If we pause, this is the fiber to unwind from.\n\n\n          currentFiber = fiber;\n\n          if (!beginFiberMark(fiber, null)) {\n            return;\n          }\n\n          fiber._debugIsCurrentlyTiming = true;\n        },\n        cancelWorkTimer: function cancelWorkTimer(fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          } // Remember we shouldn't complete measurement for this fiber.\n          // Otherwise flamechart will be deep even for small updates.\n\n\n          fiber._debugIsCurrentlyTiming = false;\n          clearFiberMark(fiber, null);\n        },\n        stopWorkTimer: function stopWorkTimer(fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          } // If we pause, its parent is the fiber to unwind from.\n\n\n          currentFiber = fiber['return'];\n\n          if (!fiber._debugIsCurrentlyTiming) {\n            return;\n          }\n\n          fiber._debugIsCurrentlyTiming = false;\n          endFiberMark(fiber, null, null);\n        },\n        stopFailedWorkTimer: function stopFailedWorkTimer(fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          } // If we pause, its parent is the fiber to unwind from.\n\n\n          currentFiber = fiber['return'];\n\n          if (!fiber._debugIsCurrentlyTiming) {\n            return;\n          }\n\n          fiber._debugIsCurrentlyTiming = false;\n          var warning$$1 = 'An error was thrown inside this error boundary';\n          endFiberMark(fiber, null, warning$$1);\n        },\n        startPhaseTimer: function startPhaseTimer(fiber, phase) {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          clearPendingPhaseMeasurement();\n\n          if (!beginFiberMark(fiber, phase)) {\n            return;\n          }\n\n          currentPhaseFiber = fiber;\n          currentPhase = phase;\n        },\n        stopPhaseTimer: function stopPhaseTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          if (currentPhase !== null && currentPhaseFiber !== null) {\n            var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n            endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n          }\n\n          currentPhase = null;\n          currentPhaseFiber = null;\n        },\n        startWorkLoopTimer: function startWorkLoopTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          commitCountInCurrentWorkLoop = 0; // This is top level call.\n          // Any other measurements are performed within.\n\n          beginMark('(React Tree Reconciliation)'); // Resume any measurements that were in progress during the last loop.\n\n          resumeTimers();\n        },\n        stopWorkLoopTimer: function stopWorkLoopTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          var warning$$1 = commitCountInCurrentWorkLoop > 1 ? 'There were cascading updates' : null;\n          commitCountInCurrentWorkLoop = 0; // Pause any measurements until the next loop.\n\n          pauseTimers();\n          endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);\n        },\n        startCommitTimer: function startCommitTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          isCommitting = true;\n          hasScheduledUpdateInCurrentCommit = false;\n          labelsInCurrentCommit.clear();\n          beginMark('(Committing Changes)');\n        },\n        stopCommitTimer: function stopCommitTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          var warning$$1 = null;\n\n          if (hasScheduledUpdateInCurrentCommit) {\n            warning$$1 = 'Lifecycle hook scheduled a cascading update';\n          } else if (commitCountInCurrentWorkLoop > 0) {\n            warning$$1 = 'Caused by a cascading update in earlier commit';\n          }\n\n          hasScheduledUpdateInCurrentCommit = false;\n          commitCountInCurrentWorkLoop++;\n          isCommitting = false;\n          labelsInCurrentCommit.clear();\n          endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n        },\n        startCommitHostEffectsTimer: function startCommitHostEffectsTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          effectCountInCurrentCommit = 0;\n          beginMark('(Committing Host Effects)');\n        },\n        stopCommitHostEffectsTimer: function stopCommitHostEffectsTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          var count = effectCountInCurrentCommit;\n          effectCountInCurrentCommit = 0;\n          endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n        },\n        startCommitLifeCyclesTimer: function startCommitLifeCyclesTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          effectCountInCurrentCommit = 0;\n          beginMark('(Calling Lifecycle Methods)');\n        },\n        stopCommitLifeCyclesTimer: function stopCommitLifeCyclesTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          var count = effectCountInCurrentCommit;\n          effectCountInCurrentCommit = 0;\n          endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n        }\n      };\n    } // TODO: convert to named exports\n    // if this doesn't inflate the bundle.\n\n    var ReactDebugFiberPerf$1 = ReactDebugFiberPerf;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var startPhaseTimer = ReactDebugFiberPerf$1.startPhaseTimer;\n    var stopPhaseTimer = ReactDebugFiberPerf$1.stopPhaseTimer;\n    {\n      var warnedAboutMissingGetChildContext = {};\n    } // A cursor to the current merged context object on the stack.\n\n    var contextStackCursor = createCursor(emptyObject); // A cursor to a boolean indicating whether the context has changed.\n\n    var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n    // We use this to get access to the parent context after we have already\n    // pushed the next context provider, and now need to merge their contexts.\n\n    var previousContext = emptyObject;\n\n    function getUnmaskedContext(workInProgress) {\n      var hasOwnContext = isContextProvider(workInProgress);\n\n      if (hasOwnContext) {\n        // If the fiber is a context provider itself, when we read its context\n        // we have already pushed its own child context on the stack. A context\n        // provider should not \"see\" its own child context. Therefore we read the\n        // previous (parent) context instead for a context provider.\n        return previousContext;\n      }\n\n      return contextStackCursor.current;\n    }\n\n    function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n      var instance = workInProgress.stateNode;\n      instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n      instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n    }\n\n    function getMaskedContext(workInProgress, unmaskedContext) {\n      var type = workInProgress.type;\n      var contextTypes = type.contextTypes;\n\n      if (!contextTypes) {\n        return emptyObject;\n      } // Avoid recreating masked context unless unmasked context has changed.\n      // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n      // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n      var instance = workInProgress.stateNode;\n\n      if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n        return instance.__reactInternalMemoizedMaskedChildContext;\n      }\n\n      var context = {};\n\n      for (var key in contextTypes) {\n        context[key] = unmaskedContext[key];\n      }\n\n      {\n        var name = getComponentName(workInProgress) || 'Unknown';\n        checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n      } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n      // Context is created before the class component is instantiated so check for instance.\n\n      if (instance) {\n        cacheContext(workInProgress, unmaskedContext, context);\n      }\n\n      return context;\n    }\n\n    function hasContextChanged() {\n      return didPerformWorkStackCursor.current;\n    }\n\n    function isContextConsumer(fiber) {\n      return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n    }\n\n    function isContextProvider(fiber) {\n      return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n    }\n\n    function popContextProvider(fiber) {\n      if (!isContextProvider(fiber)) {\n        return;\n      }\n\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n\n    function popTopLevelContextObject(fiber) {\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n\n    function pushTopLevelContextObject(fiber, context, didChange) {\n      !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      push(contextStackCursor, context, fiber);\n      push(didPerformWorkStackCursor, didChange, fiber);\n    }\n\n    function processChildContext(fiber, parentContext) {\n      var instance = fiber.stateNode;\n      var childContextTypes = fiber.type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n      // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n      if (typeof instance.getChildContext !== 'function') {\n        {\n          var componentName = getComponentName(fiber) || 'Unknown';\n\n          if (!warnedAboutMissingGetChildContext[componentName]) {\n            warnedAboutMissingGetChildContext[componentName] = true;\n            warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n          }\n        }\n        return parentContext;\n      }\n\n      var childContext = void 0;\n      {\n        ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n        startPhaseTimer(fiber, 'getChildContext');\n        childContext = instance.getChildContext();\n        stopPhaseTimer();\n        ReactDebugCurrentFiber.setCurrentPhase(null);\n      }\n\n      for (var contextKey in childContext) {\n        !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n      }\n\n      {\n        var name = getComponentName(fiber) || 'Unknown';\n        checkPropTypes(childContextTypes, childContext, 'child context', name, // In practice, there is one case in which we won't get a stack. It's when\n        // somebody calls unstable_renderSubtreeIntoContainer() and we process\n        // context from the parent component instance. The stack will be missing\n        // because it's outside of the reconciliation, and so the pointer has not\n        // been set. This is rare and doesn't matter. We'll also remove that API.\n        ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n      }\n      return _assign({}, parentContext, childContext);\n    }\n\n    function pushContextProvider(workInProgress) {\n      if (!isContextProvider(workInProgress)) {\n        return false;\n      }\n\n      var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n      // If the instance does not exist yet, we will push null at first,\n      // and replace it on the stack later when invalidating the context.\n\n      var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject; // Remember the parent context so we can merge with it later.\n      // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\n      previousContext = contextStackCursor.current;\n      push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n      push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n      return true;\n    }\n\n    function invalidateContextProvider(workInProgress, didChange) {\n      var instance = workInProgress.stateNode;\n      !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n      if (didChange) {\n        // Merge parent and own context.\n        // Skip this if we're not updating due to sCU.\n        // This avoids unnecessarily recomputing memoized values.\n        var mergedContext = processChildContext(workInProgress, previousContext);\n        instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n        // It is important to unwind the context in the reverse order.\n\n        pop(didPerformWorkStackCursor, workInProgress);\n        pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n        push(contextStackCursor, mergedContext, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      } else {\n        pop(didPerformWorkStackCursor, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      }\n    }\n\n    function resetContext() {\n      previousContext = emptyObject;\n      contextStackCursor.current = emptyObject;\n      didPerformWorkStackCursor.current = false;\n    }\n\n    function findCurrentUnmaskedContext(fiber) {\n      // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n      // makes sense elsewhere\n      !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      var node = fiber;\n\n      while (node.tag !== HostRoot) {\n        if (isContextProvider(node)) {\n          return node.stateNode.__reactInternalMemoizedMergedChildContext;\n        }\n\n        var parent = node['return'];\n        !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        node = parent;\n      }\n\n      return node.stateNode.context;\n    }\n\n    var NoWork = 0;\n    /**\n            * Copyright (c) 2013-present, Facebook, Inc.\n            *\n            * This source code is licensed under the MIT license found in the\n            * LICENSE file in the root directory of this source tree.\n            *\n            * \n            */\n    // TODO: Use an opaque type once ESLint et al support the syntax\n\n    var Sync = 1;\n    var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1\n\n    var UNIT_SIZE = 10;\n    var MAGIC_NUMBER_OFFSET = 2; // 1 unit of expiration time represents 10ms.\n\n    function msToExpirationTime(ms) {\n      // Always add an offset so that we don't clash with the magic number for NoWork.\n      return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n    }\n\n    function ceiling(num, precision) {\n      return ((num / precision | 0) + 1) * precision;\n    }\n\n    function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n      return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n    }\n\n    var NoContext = 0;\n    /**\n            * Copyright (c) 2013-present, Facebook, Inc.\n            *\n            * This source code is licensed under the MIT license found in the\n            * LICENSE file in the root directory of this source tree.\n            *\n            * \n            */\n\n    var AsyncUpdates = 1;\n    {\n      var hasBadMapPolyfill = false;\n\n      try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        /* eslint-disable no-new */\n\n        new Map([[nonExtensibleObject, null]]);\n        new Set([nonExtensibleObject]);\n        /* eslint-enable no-new */\n      } catch (e) {\n        // TODO: Consider warning about bad polyfills\n        hasBadMapPolyfill = true;\n      }\n    } // A Fiber is work on a Component that needs to be done or was done. There can\n    // be more than one per component.\n\n    {\n      var debugCounter = 1;\n    }\n\n    function FiberNode(tag, key, internalContextTag) {\n      // Instance\n      this.tag = tag;\n      this.key = key;\n      this.type = null;\n      this.stateNode = null; // Fiber\n\n      this['return'] = null;\n      this.child = null;\n      this.sibling = null;\n      this.index = 0;\n      this.ref = null;\n      this.pendingProps = null;\n      this.memoizedProps = null;\n      this.updateQueue = null;\n      this.memoizedState = null;\n      this.internalContextTag = internalContextTag; // Effects\n\n      this.effectTag = NoEffect;\n      this.nextEffect = null;\n      this.firstEffect = null;\n      this.lastEffect = null;\n      this.expirationTime = NoWork;\n      this.alternate = null;\n      {\n        this._debugID = debugCounter++;\n        this._debugSource = null;\n        this._debugOwner = null;\n        this._debugIsCurrentlyTiming = false;\n\n        if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n          Object.preventExtensions(this);\n        }\n      }\n    } // This is a constructor function, rather than a POJO constructor, still\n    // please ensure we do the following:\n    // 1) Nobody should add any instance methods on this. Instance methods can be\n    //    more difficult to predict when they get optimized and they are almost\n    //    never inlined properly in static compilers.\n    // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n    //    always know when it is a fiber.\n    // 3) We might want to experiment with using numeric keys since they are easier\n    //    to optimize in a non-JIT environment.\n    // 4) We can easily go from a constructor to a createFiber object literal if that\n    //    is faster.\n    // 5) It should be easy to port this to a C struct and keep a C implementation\n    //    compatible.\n\n\n    var createFiber = function createFiber(tag, key, internalContextTag) {\n      // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n      return new FiberNode(tag, key, internalContextTag);\n    };\n\n    function shouldConstruct(Component) {\n      return !!(Component.prototype && Component.prototype.isReactComponent);\n    } // This is used to create an alternate fiber to do work on.\n\n\n    function createWorkInProgress(current, pendingProps, expirationTime) {\n      var workInProgress = current.alternate;\n\n      if (workInProgress === null) {\n        // We use a double buffering pooling technique because we know that we'll\n        // only ever need at most two versions of a tree. We pool the \"other\" unused\n        // node that we're free to reuse. This is lazily created to avoid allocating\n        // extra objects for things that are never updated. It also allow us to\n        // reclaim the extra memory if needed.\n        workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n        workInProgress.type = current.type;\n        workInProgress.stateNode = current.stateNode;\n        {\n          // DEV-only fields\n          workInProgress._debugID = current._debugID;\n          workInProgress._debugSource = current._debugSource;\n          workInProgress._debugOwner = current._debugOwner;\n        }\n        workInProgress.alternate = current;\n        current.alternate = workInProgress;\n      } else {\n        // We already have an alternate.\n        // Reset the effect tag.\n        workInProgress.effectTag = NoEffect; // The effect list is no longer valid.\n\n        workInProgress.nextEffect = null;\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null;\n      }\n\n      workInProgress.expirationTime = expirationTime;\n      workInProgress.pendingProps = pendingProps;\n      workInProgress.child = current.child;\n      workInProgress.memoizedProps = current.memoizedProps;\n      workInProgress.memoizedState = current.memoizedState;\n      workInProgress.updateQueue = current.updateQueue; // These will be overridden during the parent's reconciliation\n\n      workInProgress.sibling = current.sibling;\n      workInProgress.index = current.index;\n      workInProgress.ref = current.ref;\n      return workInProgress;\n    }\n\n    function createHostRootFiber() {\n      var fiber = createFiber(HostRoot, null, NoContext);\n      return fiber;\n    }\n\n    function createFiberFromElement(element, internalContextTag, expirationTime) {\n      var owner = null;\n      {\n        owner = element._owner;\n      }\n      var fiber = void 0;\n      var type = element.type,\n          key = element.key;\n\n      if (typeof type === 'function') {\n        fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);\n        fiber.type = type;\n        fiber.pendingProps = element.props;\n      } else if (typeof type === 'string') {\n        fiber = createFiber(HostComponent, key, internalContextTag);\n        fiber.type = type;\n        fiber.pendingProps = element.props;\n      } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n        // Currently assumed to be a continuation and therefore is a fiber already.\n        // TODO: The yield system is currently broken for updates in some cases.\n        // The reified yield stores a fiber, but we don't know which fiber that is;\n        // the current or a workInProgress? When the continuation gets rendered here\n        // we don't know if we can reuse that fiber or if we need to clone it.\n        // There is probably a clever way to restructure this.\n        fiber = type;\n        fiber.pendingProps = element.props;\n      } else {\n        var info = '';\n        {\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in.\";\n          }\n\n          var ownerName = owner ? getComponentName(owner) : null;\n\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n        }\n        invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n      }\n\n      {\n        fiber._debugSource = element._source;\n        fiber._debugOwner = element._owner;\n      }\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {\n      var fiber = createFiber(Fragment, key, internalContextTag);\n      fiber.pendingProps = elements;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromText(content, internalContextTag, expirationTime) {\n      var fiber = createFiber(HostText, null, internalContextTag);\n      fiber.pendingProps = content;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromHostInstanceForDeletion() {\n      var fiber = createFiber(HostComponent, null, NoContext);\n      fiber.type = 'DELETED';\n      return fiber;\n    }\n\n    function createFiberFromCall(call, internalContextTag, expirationTime) {\n      var fiber = createFiber(CallComponent, call.key, internalContextTag);\n      fiber.type = call.handler;\n      fiber.pendingProps = call;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {\n      var fiber = createFiber(ReturnComponent, null, internalContextTag);\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromPortal(portal, internalContextTag, expirationTime) {\n      var fiber = createFiber(HostPortal, portal.key, internalContextTag);\n      fiber.pendingProps = portal.children || [];\n      fiber.expirationTime = expirationTime;\n      fiber.stateNode = {\n        containerInfo: portal.containerInfo,\n        pendingChildren: null,\n        // Used by persistent updates\n        implementation: portal.implementation\n      };\n      return fiber;\n    }\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    function createFiberRoot(containerInfo, hydrate) {\n      // Cyclic construction. This cheats the type system right now because\n      // stateNode is any.\n      var uninitializedFiber = createHostRootFiber();\n      var root = {\n        current: uninitializedFiber,\n        containerInfo: containerInfo,\n        pendingChildren: null,\n        remainingExpirationTime: NoWork,\n        isReadyForCommit: false,\n        finishedWork: null,\n        context: null,\n        pendingContext: null,\n        hydrate: hydrate,\n        nextScheduledRoot: null\n      };\n      uninitializedFiber.stateNode = root;\n      return root;\n    }\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var ReactErrorUtils = {\n      // Used by Fiber to simulate a try-catch.\n      _caughtError: null,\n      _hasCaughtError: false,\n      // Used by event system to capture/rethrow the first error.\n      _rethrowError: null,\n      _hasRethrowError: false,\n      injection: {\n        injectErrorUtils: function injectErrorUtils(injectedErrorUtils) {\n          !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n          invokeGuardedCallback$1 = injectedErrorUtils.invokeGuardedCallback;\n        }\n      },\n\n      /**\n       * Call a function while guarding against errors that happens within it.\n       * Returns an error if it throws, otherwise null.\n       *\n       * In production, this is implemented using a try-catch. The reason we don't\n       * use a try-catch directly is so that we can swap out a different\n       * implementation in DEV mode.\n       *\n       * @param {String} name of the guard to use for logging or debugging\n       * @param {Function} func The function to invoke\n       * @param {*} context The context to use when calling the function\n       * @param {...*} args Arguments for function\n       */\n      invokeGuardedCallback: function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n        invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n      },\n\n      /**\n       * Same as invokeGuardedCallback, but instead of returning an error, it stores\n       * it in a global so it can be rethrown by `rethrowCaughtError` later.\n       * TODO: See if _caughtError and _rethrowError can be unified.\n       *\n       * @param {String} name of the guard to use for logging or debugging\n       * @param {Function} func The function to invoke\n       * @param {*} context The context to use when calling the function\n       * @param {...*} args Arguments for function\n       */\n      invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\n        ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n\n        if (ReactErrorUtils.hasCaughtError()) {\n          var error = ReactErrorUtils.clearCaughtError();\n\n          if (!ReactErrorUtils._hasRethrowError) {\n            ReactErrorUtils._hasRethrowError = true;\n            ReactErrorUtils._rethrowError = error;\n          }\n        }\n      },\n\n      /**\n       * During execution of guarded functions we will capture the first error which\n       * we will rethrow to be handled by the top level error handler.\n       */\n      rethrowCaughtError: function rethrowCaughtError() {\n        return _rethrowCaughtError.apply(ReactErrorUtils, arguments);\n      },\n      hasCaughtError: function hasCaughtError() {\n        return ReactErrorUtils._hasCaughtError;\n      },\n      clearCaughtError: function clearCaughtError() {\n        if (ReactErrorUtils._hasCaughtError) {\n          var error = ReactErrorUtils._caughtError;\n          ReactErrorUtils._caughtError = null;\n          ReactErrorUtils._hasCaughtError = false;\n          return error;\n        } else {\n          invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n    };\n\n    var invokeGuardedCallback$1 = function invokeGuardedCallback$1(name, func, context, a, b, c, d, e, f) {\n      ReactErrorUtils._hasCaughtError = false;\n      ReactErrorUtils._caughtError = null;\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n      try {\n        func.apply(context, funcArgs);\n      } catch (error) {\n        ReactErrorUtils._caughtError = error;\n        ReactErrorUtils._hasCaughtError = true;\n      }\n    };\n\n    {\n      // In DEV mode, we swap out invokeGuardedCallback for a special version\n      // that plays more nicely with the browser's DevTools. The idea is to preserve\n      // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n      // functions in invokeGuardedCallback, and the production version of\n      // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n      // like caught exceptions, and the DevTools won't pause unless the developer\n      // takes the extra step of enabling pause on caught exceptions. This is\n      // untintuitive, though, because even though React has caught the error, from\n      // the developer's perspective, the error is uncaught.\n      //\n      // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n      // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n      // DOM node, and call the user-provided callback from inside an event handler\n      // for that fake event. If the callback throws, the error is \"captured\" using\n      // a global event handler. But because the error happens in a different\n      // event loop context, it does not interrupt the normal program flow.\n      // Effectively, this gives us try-catch behavior without actually using\n      // try-catch. Neat!\n      // Check that the browser supports the APIs we need to implement our special\n      // DEV version of invokeGuardedCallback\n      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n        var fakeNode = document.createElement('react');\n\n        var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n          // Keeps track of whether the user-provided callback threw an error. We\n          // set this to true at the beginning, then set it to false right after\n          // calling the function. If the function errors, `didError` will never be\n          // set to false. This strategy works even if the browser is flaky and\n          // fails to call our global error handler, because it doesn't rely on\n          // the error event at all.\n          var didError = true; // Create an event handler for our fake event. We will synchronously\n          // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n          // call the user-provided callback.\n\n          var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n          function callCallback() {\n            // We immediately remove the callback from event listeners so that\n            // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n            // nested call would trigger the fake event handlers of any call higher\n            // in the stack.\n            fakeNode.removeEventListener(evtType, callCallback, false);\n            func.apply(context, funcArgs);\n            didError = false;\n          } // Create a global error event handler. We use this to capture the value\n          // that was thrown. It's possible that this error handler will fire more\n          // than once; for example, if non-React code also calls `dispatchEvent`\n          // and a handler for that event throws. We should be resilient to most of\n          // those cases. Even if our error event handler fires more than once, the\n          // last error event is always used. If the callback actually does error,\n          // we know that the last error event is the correct one, because it's not\n          // possible for anything else to have happened in between our callback\n          // erroring and the code that follows the `dispatchEvent` call below. If\n          // the callback doesn't error, but the error event was fired, we know to\n          // ignore it because `didError` will be false, as described above.\n\n\n          var error = void 0; // Use this to track whether the error event is ever called.\n\n          var didSetError = false;\n          var isCrossOriginError = false;\n\n          function onError(event) {\n            error = event.error;\n            didSetError = true;\n\n            if (error === null && event.colno === 0 && event.lineno === 0) {\n              isCrossOriginError = true;\n            }\n          } // Create a fake event type.\n\n\n          var evtType = 'react-' + (name ? name : 'invokeguardedcallback'); // Attach our event handlers\n\n          window.addEventListener('error', onError);\n          fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function\n          // errors, it will trigger our global error handler.\n\n          var evt = document.createEvent('Event');\n          evt.initEvent(evtType, false, false);\n          fakeNode.dispatchEvent(evt);\n\n          if (didError) {\n            if (!didSetError) {\n              // The callback errored, but the error event never fired.\n              error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n            } else if (isCrossOriginError) {\n              error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n            }\n\n            ReactErrorUtils._hasCaughtError = true;\n            ReactErrorUtils._caughtError = error;\n          } else {\n            ReactErrorUtils._hasCaughtError = false;\n            ReactErrorUtils._caughtError = null;\n          } // Remove our event listeners\n\n\n          window.removeEventListener('error', onError);\n        };\n\n        invokeGuardedCallback$1 = invokeGuardedCallbackDev;\n      }\n    }\n\n    var _rethrowCaughtError = function _rethrowCaughtError() {\n      if (ReactErrorUtils._hasRethrowError) {\n        var error = ReactErrorUtils._rethrowError;\n        ReactErrorUtils._rethrowError = null;\n        ReactErrorUtils._hasRethrowError = false;\n        throw error;\n      }\n    };\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    {\n      var didWarnUpdateInsideUpdate = false;\n    } // Callbacks are not validated until invocation\n    // Singly linked-list of updates. When an update is scheduled, it is added to\n    // the queue of the current fiber and the work-in-progress fiber. The two queues\n    // are separate but they share a persistent structure.\n    //\n    // During reconciliation, updates are removed from the work-in-progress fiber,\n    // but they remain on the current fiber. That ensures that if a work-in-progress\n    // is aborted, the aborted updates are recovered by cloning from current.\n    //\n    // The work-in-progress queue is always a subset of the current queue.\n    //\n    // When the tree is committed, the work-in-progress becomes the current.\n\n    function createUpdateQueue(baseState) {\n      var queue = {\n        baseState: baseState,\n        expirationTime: NoWork,\n        first: null,\n        last: null,\n        callbackList: null,\n        hasForceUpdate: false,\n        isInitialized: false\n      };\n      {\n        queue.isProcessing = false;\n      }\n      return queue;\n    }\n\n    function insertUpdateIntoQueue(queue, update) {\n      // Append the update to the end of the list.\n      if (queue.last === null) {\n        // Queue is empty\n        queue.first = queue.last = update;\n      } else {\n        queue.last.next = update;\n        queue.last = update;\n      }\n\n      if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n        queue.expirationTime = update.expirationTime;\n      }\n    }\n\n    function insertUpdateIntoFiber(fiber, update) {\n      // We'll have at least one and at most two distinct update queues.\n      var alternateFiber = fiber.alternate;\n      var queue1 = fiber.updateQueue;\n\n      if (queue1 === null) {\n        // TODO: We don't know what the base state will be until we begin work.\n        // It depends on which fiber is the next current. Initialize with an empty\n        // base state, then set to the memoizedState when rendering. Not super\n        // happy with this approach.\n        queue1 = fiber.updateQueue = createUpdateQueue(null);\n      }\n\n      var queue2 = void 0;\n\n      if (alternateFiber !== null) {\n        queue2 = alternateFiber.updateQueue;\n\n        if (queue2 === null) {\n          queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n        }\n      } else {\n        queue2 = null;\n      }\n\n      queue2 = queue2 !== queue1 ? queue2 : null; // Warn if an update is scheduled from inside an updater function.\n\n      {\n        if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n          warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n          didWarnUpdateInsideUpdate = true;\n        }\n      } // If there's only one queue, add the update to that queue and exit.\n\n      if (queue2 === null) {\n        insertUpdateIntoQueue(queue1, update);\n        return;\n      } // If either queue is empty, we need to add to both queues.\n\n\n      if (queue1.last === null || queue2.last === null) {\n        insertUpdateIntoQueue(queue1, update);\n        insertUpdateIntoQueue(queue2, update);\n        return;\n      } // If both lists are not empty, the last update is the same for both lists\n      // because of structural sharing. So, we should only append to one of\n      // the lists.\n\n\n      insertUpdateIntoQueue(queue1, update); // But we still need to update the `last` pointer of queue2.\n\n      queue2.last = update;\n    }\n\n    function getUpdateExpirationTime(fiber) {\n      if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {\n        return NoWork;\n      }\n\n      var updateQueue = fiber.updateQueue;\n\n      if (updateQueue === null) {\n        return NoWork;\n      }\n\n      return updateQueue.expirationTime;\n    }\n\n    function getStateFromUpdate(update, instance, prevState, props) {\n      var partialState = update.partialState;\n\n      if (typeof partialState === 'function') {\n        var updateFn = partialState;\n        return updateFn.call(instance, prevState, props);\n      } else {\n        return partialState;\n      }\n    }\n\n    function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n      if (current !== null && current.updateQueue === queue) {\n        // We need to create a work-in-progress queue, by cloning the current queue.\n        var currentQueue = queue;\n        queue = workInProgress.updateQueue = {\n          baseState: currentQueue.baseState,\n          expirationTime: currentQueue.expirationTime,\n          first: currentQueue.first,\n          last: currentQueue.last,\n          isInitialized: currentQueue.isInitialized,\n          // These fields are no longer valid because they were already committed.\n          // Reset them.\n          callbackList: null,\n          hasForceUpdate: false\n        };\n      }\n\n      {\n        // Set this flag so we can warn if setState is called inside the update\n        // function of another setState.\n        queue.isProcessing = true;\n      } // Reset the remaining expiration time. If we skip over any updates, we'll\n      // increase this accordingly.\n\n      queue.expirationTime = NoWork; // TODO: We don't know what the base state will be until we begin work.\n      // It depends on which fiber is the next current. Initialize with an empty\n      // base state, then set to the memoizedState when rendering. Not super\n      // happy with this approach.\n\n      var state = void 0;\n\n      if (queue.isInitialized) {\n        state = queue.baseState;\n      } else {\n        state = queue.baseState = workInProgress.memoizedState;\n        queue.isInitialized = true;\n      }\n\n      var dontMutatePrevState = true;\n      var update = queue.first;\n      var didSkip = false;\n\n      while (update !== null) {\n        var updateExpirationTime = update.expirationTime;\n\n        if (updateExpirationTime > renderExpirationTime) {\n          // This update does not have sufficient priority. Skip it.\n          var remainingExpirationTime = queue.expirationTime;\n\n          if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n            // Update the remaining expiration time.\n            queue.expirationTime = updateExpirationTime;\n          }\n\n          if (!didSkip) {\n            didSkip = true;\n            queue.baseState = state;\n          } // Continue to the next update.\n\n\n          update = update.next;\n          continue;\n        } // This update does have sufficient priority.\n        // If no previous updates were skipped, drop this update from the queue by\n        // advancing the head of the list.\n\n\n        if (!didSkip) {\n          queue.first = update.next;\n\n          if (queue.first === null) {\n            queue.last = null;\n          }\n        } // Process the update\n\n\n        var _partialState = void 0;\n\n        if (update.isReplace) {\n          state = getStateFromUpdate(update, instance, state, props);\n          dontMutatePrevState = true;\n        } else {\n          _partialState = getStateFromUpdate(update, instance, state, props);\n\n          if (_partialState) {\n            if (dontMutatePrevState) {\n              // $FlowFixMe: Idk how to type this properly.\n              state = _assign({}, state, _partialState);\n            } else {\n              state = _assign(state, _partialState);\n            }\n\n            dontMutatePrevState = false;\n          }\n        }\n\n        if (update.isForced) {\n          queue.hasForceUpdate = true;\n        }\n\n        if (update.callback !== null) {\n          // Append to list of callbacks.\n          var _callbackList = queue.callbackList;\n\n          if (_callbackList === null) {\n            _callbackList = queue.callbackList = [];\n          }\n\n          _callbackList.push(update);\n        }\n\n        update = update.next;\n      }\n\n      if (queue.callbackList !== null) {\n        workInProgress.effectTag |= Callback;\n      } else if (queue.first === null && !queue.hasForceUpdate) {\n        // The queue is empty. We can reset it.\n        workInProgress.updateQueue = null;\n      }\n\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n\n      {\n        // No longer processing.\n        queue.isProcessing = false;\n      }\n      return state;\n    }\n\n    function commitCallbacks(queue, context) {\n      var callbackList = queue.callbackList;\n\n      if (callbackList === null) {\n        return;\n      } // Set the list to null to make sure they don't get called more than once.\n\n\n      queue.callbackList = null;\n\n      for (var i = 0; i < callbackList.length; i++) {\n        var update = callbackList[i];\n        var _callback = update.callback; // This update might be processed again. Clear the callback so it's only\n        // called once.\n\n        update.callback = null;\n        !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n\n        _callback.call(context);\n      }\n    }\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var startPhaseTimer$1 = ReactDebugFiberPerf$1.startPhaseTimer;\n    var stopPhaseTimer$1 = ReactDebugFiberPerf$1.stopPhaseTimer;\n    var fakeInternalInstance = {};\n    var isArray = Array.isArray;\n    {\n      var didWarnAboutStateAssignmentForComponent = {};\n\n      var warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {\n        warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n      }; // This is so gross but it's at least non-critical and can be removed if\n      // it causes problems. This is meant to give a nicer error message for\n      // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n      // ...)) which otherwise throws a \"_processChildContext is not a function\"\n      // exception.\n\n\n      Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n        enumerable: false,\n        value: function value() {\n          invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n        }\n      });\n      Object.freeze(fakeInternalInstance);\n    }\n\n    var ReactFiberClassComponent = function ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n      // Class component state updater\n      var updater = {\n        isMounted: isMounted,\n        enqueueSetState: function enqueueSetState(instance, partialState, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'setState');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: partialState,\n            callback: callback,\n            isReplace: false,\n            isForced: false,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        },\n        enqueueReplaceState: function enqueueReplaceState(instance, state, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'replaceState');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: state,\n            callback: callback,\n            isReplace: true,\n            isForced: false,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        },\n        enqueueForceUpdate: function enqueueForceUpdate(instance, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'forceUpdate');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: null,\n            callback: callback,\n            isReplace: false,\n            isForced: true,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        }\n      };\n\n      function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n        if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n          // If the workInProgress already has an Update effect, return true\n          return true;\n        }\n\n        var instance = workInProgress.stateNode;\n        var type = workInProgress.type;\n\n        if (typeof instance.shouldComponentUpdate === 'function') {\n          {\n            startPhaseTimer$1(workInProgress, 'shouldComponentUpdate');\n          }\n          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n          {\n            stopPhaseTimer$1();\n          }\n          {\n            warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');\n          }\n          return shouldUpdate;\n        }\n\n        if (type.prototype && type.prototype.isPureReactComponent) {\n          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n        }\n\n        return true;\n      }\n\n      function checkClassInstance(workInProgress) {\n        var instance = workInProgress.stateNode;\n        var type = workInProgress.type;\n        {\n          var name = getComponentName(workInProgress);\n          var renderPresent = instance.render;\n\n          if (!renderPresent) {\n            if (type.prototype && typeof type.prototype.render === 'function') {\n              warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n            } else {\n              warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n            }\n          }\n\n          var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n          warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n          var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n          warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n          var noInstancePropTypes = !instance.propTypes;\n          warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n          var noInstanceContextTypes = !instance.contextTypes;\n          warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n          var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n          warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n\n          if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n            warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n          }\n\n          var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n          warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n          var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n          warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n          var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n          warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n          var noInstanceDefaultProps = !instance.defaultProps;\n          warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n        }\n        var state = instance.state;\n\n        if (state && (typeof state !== 'object' || isArray(state))) {\n          invariant(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));\n        }\n\n        if (typeof instance.getChildContext === 'function') {\n          !(typeof workInProgress.type.childContextTypes === 'object') ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', getComponentName(workInProgress)) : void 0;\n        }\n      }\n\n      function resetInputPointers(workInProgress, instance) {\n        instance.props = workInProgress.memoizedProps;\n        instance.state = workInProgress.memoizedState;\n      }\n\n      function adoptClassInstance(workInProgress, instance) {\n        instance.updater = updater;\n        workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n        set(instance, workInProgress);\n        {\n          instance._reactInternalInstance = fakeInternalInstance;\n        }\n      }\n\n      function constructClassInstance(workInProgress, props) {\n        var ctor = workInProgress.type;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var needsContext = isContextConsumer(workInProgress);\n        var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n        var instance = new ctor(props, context);\n        adoptClassInstance(workInProgress, instance); // Cache unmasked context so we can avoid recreating masked context unless necessary.\n        // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n        if (needsContext) {\n          cacheContext(workInProgress, unmaskedContext, context);\n        }\n\n        return instance;\n      }\n\n      function callComponentWillMount(workInProgress, instance) {\n        {\n          startPhaseTimer$1(workInProgress, 'componentWillMount');\n        }\n        var oldState = instance.state;\n        instance.componentWillMount();\n        {\n          stopPhaseTimer$1();\n        }\n\n        if (oldState !== instance.state) {\n          {\n            warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress));\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      }\n\n      function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n        {\n          startPhaseTimer$1(workInProgress, 'componentWillReceiveProps');\n        }\n        var oldState = instance.state;\n        instance.componentWillReceiveProps(newProps, newContext);\n        {\n          stopPhaseTimer$1();\n        }\n\n        if (instance.state !== oldState) {\n          {\n            var componentName = getComponentName(workInProgress) || 'Component';\n\n            if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n              warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n              didWarnAboutStateAssignmentForComponent[componentName] = true;\n            }\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      } // Invokes the mount life-cycles on a previously never rendered instance.\n\n\n      function mountClassInstance(workInProgress, renderExpirationTime) {\n        var current = workInProgress.alternate;\n        {\n          checkClassInstance(workInProgress);\n        }\n        var instance = workInProgress.stateNode;\n        var state = instance.state || null;\n        var props = workInProgress.pendingProps;\n        !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        instance.props = props;\n        instance.state = workInProgress.memoizedState = state;\n        instance.refs = emptyObject;\n        instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n        if (ReactFeatureFlags.enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n          workInProgress.internalContextTag |= AsyncUpdates;\n        }\n\n        if (typeof instance.componentWillMount === 'function') {\n          callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n          // process them now.\n\n          var updateQueue = workInProgress.updateQueue;\n\n          if (updateQueue !== null) {\n            instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n          }\n        }\n\n        if (typeof instance.componentDidMount === 'function') {\n          workInProgress.effectTag |= Update;\n        }\n      } // Called on a preexisting class instance. Returns false if a resumed render\n      // could be reused.\n      // function resumeMountClassInstance(\n      //   workInProgress: Fiber,\n      //   priorityLevel: PriorityLevel,\n      // ): boolean {\n      //   const instance = workInProgress.stateNode;\n      //   resetInputPointers(workInProgress, instance);\n      //   let newState = workInProgress.memoizedState;\n      //   let newProps = workInProgress.pendingProps;\n      //   if (!newProps) {\n      //     // If there isn't any new props, then we'll reuse the memoized props.\n      //     // This could be from already completed work.\n      //     newProps = workInProgress.memoizedProps;\n      //     invariant(\n      //       newProps != null,\n      //       'There should always be pending or memoized props. This error is ' +\n      //         'likely caused by a bug in React. Please file an issue.',\n      //     );\n      //   }\n      //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n      //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n      //   const oldContext = instance.context;\n      //   const oldProps = workInProgress.memoizedProps;\n      //   if (\n      //     typeof instance.componentWillReceiveProps === 'function' &&\n      //     (oldProps !== newProps || oldContext !== newContext)\n      //   ) {\n      //     callComponentWillReceiveProps(\n      //       workInProgress,\n      //       instance,\n      //       newProps,\n      //       newContext,\n      //     );\n      //   }\n      //   // Process the update queue before calling shouldComponentUpdate\n      //   const updateQueue = workInProgress.updateQueue;\n      //   if (updateQueue !== null) {\n      //     newState = processUpdateQueue(\n      //       workInProgress,\n      //       updateQueue,\n      //       instance,\n      //       newState,\n      //       newProps,\n      //       priorityLevel,\n      //     );\n      //   }\n      //   // TODO: Should we deal with a setState that happened after the last\n      //   // componentWillMount and before this componentWillMount? Probably\n      //   // unsupported anyway.\n      //   if (\n      //     !checkShouldComponentUpdate(\n      //       workInProgress,\n      //       workInProgress.memoizedProps,\n      //       newProps,\n      //       workInProgress.memoizedState,\n      //       newState,\n      //       newContext,\n      //     )\n      //   ) {\n      //     // Update the existing instance's state, props, and context pointers even\n      //     // though we're bailing out.\n      //     instance.props = newProps;\n      //     instance.state = newState;\n      //     instance.context = newContext;\n      //     return false;\n      //   }\n      //   // Update the input pointers now so that they are correct when we call\n      //   // componentWillMount\n      //   instance.props = newProps;\n      //   instance.state = newState;\n      //   instance.context = newContext;\n      //   if (typeof instance.componentWillMount === 'function') {\n      //     callComponentWillMount(workInProgress, instance);\n      //     // componentWillMount may have called setState. Process the update queue.\n      //     const newUpdateQueue = workInProgress.updateQueue;\n      //     if (newUpdateQueue !== null) {\n      //       newState = processUpdateQueue(\n      //         workInProgress,\n      //         newUpdateQueue,\n      //         instance,\n      //         newState,\n      //         newProps,\n      //         priorityLevel,\n      //       );\n      //     }\n      //   }\n      //   if (typeof instance.componentDidMount === 'function') {\n      //     workInProgress.effectTag |= Update;\n      //   }\n      //   instance.state = newState;\n      //   return true;\n      // }\n      // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\n      function updateClassInstance(current, workInProgress, renderExpirationTime) {\n        var instance = workInProgress.stateNode;\n        resetInputPointers(workInProgress, instance);\n        var oldProps = workInProgress.memoizedProps;\n        var newProps = workInProgress.pendingProps;\n\n        if (!newProps) {\n          // If there aren't any new props, then we'll reuse the memoized props.\n          // This could be from already completed work.\n          newProps = oldProps;\n          !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        }\n\n        var oldContext = instance.context;\n        var newUnmaskedContext = getUnmaskedContext(workInProgress);\n        var newContext = getMaskedContext(workInProgress, newUnmaskedContext); // Note: During these life-cycles, instance.props/instance.state are what\n        // ever the previously attempted to render - not the \"current\". However,\n        // during componentDidUpdate we pass the \"current\" props.\n\n        if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n          callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n        } // Compute the next state using the memoized state and the update queue.\n\n\n        var oldState = workInProgress.memoizedState; // TODO: Previous state can be null.\n\n        var newState = void 0;\n\n        if (workInProgress.updateQueue !== null) {\n          newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n        } else {\n          newState = oldState;\n        }\n\n        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n          // If an update was already in progress, we should schedule an Update\n          // effect even though we're bailing out, so that cWU/cDU are called.\n          if (typeof instance.componentDidUpdate === 'function') {\n            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n              workInProgress.effectTag |= Update;\n            }\n          }\n\n          return false;\n        }\n\n        var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n        if (shouldUpdate) {\n          if (typeof instance.componentWillUpdate === 'function') {\n            {\n              startPhaseTimer$1(workInProgress, 'componentWillUpdate');\n            }\n            instance.componentWillUpdate(newProps, newState, newContext);\n            {\n              stopPhaseTimer$1();\n            }\n          }\n\n          if (typeof instance.componentDidUpdate === 'function') {\n            workInProgress.effectTag |= Update;\n          }\n        } else {\n          // If an update was already in progress, we should schedule an Update\n          // effect even though we're bailing out, so that cWU/cDU are called.\n          if (typeof instance.componentDidUpdate === 'function') {\n            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n              workInProgress.effectTag |= Update;\n            }\n          } // If shouldComponentUpdate returned false, we should still update the\n          // memoized props/state to indicate that this work can be reused.\n\n\n          memoizeProps(workInProgress, newProps);\n          memoizeState(workInProgress, newState);\n        } // Update the existing instance's state, props, and context pointers even\n        // if shouldComponentUpdate returns false.\n\n\n        instance.props = newProps;\n        instance.state = newState;\n        instance.context = newContext;\n        return shouldUpdate;\n      }\n\n      return {\n        adoptClassInstance: adoptClassInstance,\n        constructClassInstance: constructClassInstance,\n        mountClassInstance: mountClassInstance,\n        // resumeMountClassInstance,\n        updateClassInstance: updateClassInstance\n      };\n    }; // The Symbol used to tag the special React types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n\n    var REACT_PORTAL_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca;\n    /**\n            * Copyright (c) 2014-present, Facebook, Inc.\n            *\n            * This source code is licensed under the MIT license found in the\n            * LICENSE file in the root directory of this source tree.\n            *\n            * \n            */\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n    var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n    {\n      var didWarnAboutMaps = false;\n      /**\n       * Warn if there's no key explicitly set on dynamic arrays of children or\n       * object keys are not valid. This allows us to keep track of children between\n       * updates.\n       */\n\n      var ownerHasKeyUseWarning = {};\n      var ownerHasFunctionTypeWarning = {};\n\n      var warnForMissingKey = function warnForMissingKey(child) {\n        if (child === null || typeof child !== 'object') {\n          return;\n        }\n\n        if (!child._store || child._store.validated || child.key != null) {\n          return;\n        }\n\n        !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        child._store.validated = true;\n        var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n        warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());\n      };\n    }\n    var isArray$1 = Array.isArray;\n    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n    var REACT_ELEMENT_TYPE;\n    var REACT_CALL_TYPE;\n    var REACT_RETURN_TYPE;\n    var REACT_FRAGMENT_TYPE;\n\n    if (typeof Symbol === 'function' && Symbol['for']) {\n      REACT_ELEMENT_TYPE = Symbol['for']('react.element');\n      REACT_CALL_TYPE = Symbol['for']('react.call');\n      REACT_RETURN_TYPE = Symbol['for']('react.return');\n      REACT_FRAGMENT_TYPE = Symbol['for']('react.fragment');\n    } else {\n      REACT_ELEMENT_TYPE = 0xeac7;\n      REACT_CALL_TYPE = 0xeac8;\n      REACT_RETURN_TYPE = 0xeac9;\n      REACT_FRAGMENT_TYPE = 0xeacb;\n    }\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n        return null;\n      }\n\n      var iteratorFn = ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof iteratorFn === 'function') {\n        return iteratorFn;\n      }\n\n      return null;\n    }\n\n    function coerceRef(current, element) {\n      var mixedRef = element.ref;\n\n      if (mixedRef !== null && typeof mixedRef !== 'function') {\n        if (element._owner) {\n          var owner = element._owner;\n          var inst = void 0;\n\n          if (owner) {\n            var ownerFiber = owner;\n            !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n            inst = ownerFiber.stateNode;\n          }\n\n          !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n          var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n          if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n            return current.ref;\n          }\n\n          var ref = function ref(value) {\n            var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n\n            if (value === null) {\n              delete refs[stringRef];\n            } else {\n              refs[stringRef] = value;\n            }\n          };\n\n          ref._stringRef = stringRef;\n          return ref;\n        } else {\n          !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n          !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n        }\n      }\n\n      return mixedRef;\n    }\n\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n      if (returnFiber.type !== 'textarea') {\n        var addendum = '';\n        {\n          addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');\n        }\n        invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n      }\n    }\n\n    function warnOnFunctionType() {\n      var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');\n\n      if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n        return;\n      }\n\n      ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n      warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');\n    } // This wrapper function exists because I expect to clone the code in each path\n    // to be able to optimize each path individually by branching early. This needs\n    // a compiler or we can do it manually. Helpers that don't need this branching\n    // live outside of this function.\n\n\n    function ChildReconciler(shouldClone, shouldTrackSideEffects) {\n      function deleteChild(returnFiber, childToDelete) {\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return;\n        }\n\n        if (!shouldClone) {\n          // When we're reconciling in place we have a work in progress copy. We\n          // actually want the current copy. If there is no current copy, then we\n          // don't need to track deletion side-effects.\n          if (childToDelete.alternate === null) {\n            return;\n          }\n\n          childToDelete = childToDelete.alternate;\n        } // Deletions are added in reversed order so we add it to the front.\n        // At this point, the return fiber's effect list is empty except for\n        // deletions, so we can just append the deletion to the list. The remaining\n        // effects aren't added until the complete phase. Once we implement\n        // resuming, this may not be true.\n\n\n        var last = returnFiber.lastEffect;\n\n        if (last !== null) {\n          last.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n\n        childToDelete.nextEffect = null;\n        childToDelete.effectTag = Deletion;\n      }\n\n      function deleteRemainingChildren(returnFiber, currentFirstChild) {\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return null;\n        } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n        // assuming that after the first child we've already added everything.\n\n\n        var childToDelete = currentFirstChild;\n\n        while (childToDelete !== null) {\n          deleteChild(returnFiber, childToDelete);\n          childToDelete = childToDelete.sibling;\n        }\n\n        return null;\n      }\n\n      function mapRemainingChildren(returnFiber, currentFirstChild) {\n        // Add the remaining children to a temporary map so that we can find them by\n        // keys quickly. Implicit (null) keys get added to this set with their index\n        var existingChildren = new Map();\n        var existingChild = currentFirstChild;\n\n        while (existingChild !== null) {\n          if (existingChild.key !== null) {\n            existingChildren.set(existingChild.key, existingChild);\n          } else {\n            existingChildren.set(existingChild.index, existingChild);\n          }\n\n          existingChild = existingChild.sibling;\n        }\n\n        return existingChildren;\n      }\n\n      function useFiber(fiber, pendingProps, expirationTime) {\n        // We currently set sibling to null and index to 0 here because it is easy\n        // to forget to do before returning it. E.g. for the single child case.\n        if (shouldClone) {\n          var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n          clone.index = 0;\n          clone.sibling = null;\n          return clone;\n        } else {\n          // We override the expiration time even if it is earlier, because if\n          // we're reconciling at a later time that means that this was\n          // down-prioritized.\n          fiber.expirationTime = expirationTime;\n          fiber.effectTag = NoEffect;\n          fiber.index = 0;\n          fiber.sibling = null;\n          fiber.pendingProps = pendingProps;\n          return fiber;\n        }\n      }\n\n      function placeChild(newFiber, lastPlacedIndex, newIndex) {\n        newFiber.index = newIndex;\n\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return lastPlacedIndex;\n        }\n\n        var current = newFiber.alternate;\n\n        if (current !== null) {\n          var oldIndex = current.index;\n\n          if (oldIndex < lastPlacedIndex) {\n            // This is a move.\n            newFiber.effectTag = Placement;\n            return lastPlacedIndex;\n          } else {\n            // This item can stay in place.\n            return oldIndex;\n          }\n        } else {\n          // This is an insertion.\n          newFiber.effectTag = Placement;\n          return lastPlacedIndex;\n        }\n      }\n\n      function placeSingleChild(newFiber) {\n        // This is simpler for the single child case. We only need to do a\n        // placement for inserting new children.\n        if (shouldTrackSideEffects && newFiber.alternate === null) {\n          newFiber.effectTag = Placement;\n        }\n\n        return newFiber;\n      }\n\n      function updateTextNode(returnFiber, current, textContent, expirationTime) {\n        if (current === null || current.tag !== HostText) {\n          // Insert\n          var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, textContent, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateElement(returnFiber, current, element, expirationTime) {\n        if (current !== null && current.type === element.type) {\n          // Move based on index\n          var existing = useFiber(current, element.props, expirationTime);\n          existing.ref = coerceRef(current, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          // Insert\n          var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n          created.ref = coerceRef(current, element);\n          created['return'] = returnFiber;\n          return created;\n        }\n      }\n\n      function updateCall(returnFiber, current, call, expirationTime) {\n        // TODO: Should this also compare handler to determine whether to reuse?\n        if (current === null || current.tag !== CallComponent) {\n          // Insert\n          var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, call, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateReturn(returnFiber, current, returnNode, expirationTime) {\n        if (current === null || current.tag !== ReturnComponent) {\n          // Insert\n          var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n          created.type = returnNode.value;\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, null, expirationTime);\n          existing.type = returnNode.value;\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updatePortal(returnFiber, current, portal, expirationTime) {\n        if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n          // Insert\n          var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n        if (current === null || current.tag !== Fragment) {\n          // Insert\n          var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, fragment, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function createChild(returnFiber, newChild, expirationTime) {\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a text\n          // node.\n          var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                if (newChild.type === REACT_FRAGMENT_TYPE) {\n                  var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);\n\n                  _created['return'] = returnFiber;\n                  return _created;\n                } else {\n                  var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);\n\n                  _created2.ref = coerceRef(null, newChild);\n                  _created2['return'] = returnFiber;\n                  return _created2;\n                }\n              }\n\n            case REACT_CALL_TYPE:\n              {\n                var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);\n\n                _created3['return'] = returnFiber;\n                return _created3;\n              }\n\n            case REACT_RETURN_TYPE:\n              {\n                var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);\n\n                _created4.type = newChild.value;\n                _created4['return'] = returnFiber;\n                return _created4;\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);\n\n                _created5['return'] = returnFiber;\n                return _created5;\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);\n\n            _created6['return'] = returnFiber;\n            return _created6;\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n        // Update the fiber if the keys match, otherwise return null.\n        var key = oldFiber !== null ? oldFiber.key : null;\n\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a text\n          // node.\n          if (key !== null) {\n            return null;\n          }\n\n          return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                if (newChild.key === key) {\n                  if (newChild.type === REACT_FRAGMENT_TYPE) {\n                    return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n                  }\n\n                  return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_CALL_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updateCall(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_RETURN_TYPE:\n              {\n                // Returns don't have keys. If the previous node is implicitly keyed\n                // we can continue to replace it without aborting even if it is not a\n                // yield.\n                if (key === null) {\n                  return updateReturn(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            if (key !== null) {\n              return null;\n            }\n\n            return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys, so we neither have to check the old nor\n          // new node for the key. If both are text nodes, they match.\n          var matchedFiber = existingChildren.get(newIdx) || null;\n          return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                if (newChild.type === REACT_FRAGMENT_TYPE) {\n                  return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n                }\n\n                return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n              }\n\n            case REACT_CALL_TYPE:\n              {\n                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);\n              }\n\n            case REACT_RETURN_TYPE:\n              {\n                // Returns don't have keys, so we neither have to check the old nor\n                // new node for the key. If both are returns, they match.\n                var _matchedFiber3 = existingChildren.get(newIdx) || null;\n\n                return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            var _matchedFiber5 = existingChildren.get(newIdx) || null;\n\n            return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n      /**\n       * Warns if there is a duplicate or missing key\n       */\n\n\n      function warnOnInvalidKey(child, knownKeys) {\n        {\n          if (typeof child !== 'object' || child === null) {\n            return knownKeys;\n          }\n\n          switch (child.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n            case REACT_CALL_TYPE:\n            case REACT_PORTAL_TYPE:\n              warnForMissingKey(child);\n              var key = child.key;\n\n              if (typeof key !== 'string') {\n                break;\n              }\n\n              if (knownKeys === null) {\n                knownKeys = new Set();\n                knownKeys.add(key);\n                break;\n              }\n\n              if (!knownKeys.has(key)) {\n                knownKeys.add(key);\n                break;\n              }\n\n              warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());\n              break;\n\n            default:\n              break;\n          }\n        }\n        return knownKeys;\n      }\n\n      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n        // This algorithm can't optimize by searching from boths ends since we\n        // don't have backpointers on fibers. I'm trying to see how far we can get\n        // with that model. If it ends up not being worth the tradeoffs, we can\n        // add it later.\n        // Even with a two ended optimization, we'd want to optimize for the case\n        // where there are few changes and brute force the comparison instead of\n        // going for the Map. It'd like to explore hitting that path first in\n        // forward-only mode and only go for the Map once we notice that we need\n        // lots of look ahead. This doesn't handle reversal as well as two ended\n        // search but that's unusual. Besides, for the two ended optimization to\n        // work on Iterables, we'd need to copy the whole set.\n        // In this first iteration, we'll just live with hitting the bad case\n        // (adding everything to a Map) in for every insert/move.\n        // If you change this code, also update reconcileChildrenIterator() which\n        // uses the same algorithm.\n        {\n          // First, validate keys.\n          var knownKeys = null;\n\n          for (var i = 0; i < newChildren.length; i++) {\n            var child = newChildren[i];\n            knownKeys = warnOnInvalidKey(child, knownKeys);\n          }\n        }\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n\n        for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n\n          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n\n          if (newFiber === null) {\n            // TODO: This breaks on empty slots like null children. That's\n            // unfortunate because it triggers the slow path all the time. We need\n            // a better way to communicate whether this was a miss or null,\n            // boolean, undefined, etc.\n            if (oldFiber === null) {\n              oldFiber = nextOldFiber;\n            }\n\n            break;\n          }\n\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              // We matched the slot, but we didn't reuse the existing fiber, so we\n              // need to delete the existing child.\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n          if (previousNewFiber === null) {\n            // TODO: Move out of the loop. This only happens for the first run.\n            resultingFirstChild = newFiber;\n          } else {\n            // TODO: Defer siblings if we're not at the right index for this slot.\n            // I.e. if we had null values before, then we want to defer this\n            // for each null value. However, we also don't want to call updateSlot\n            // with the previous one.\n            previousNewFiber.sibling = newFiber;\n          }\n\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n\n        if (newIdx === newChildren.length) {\n          // We've reached the end of the new children. We can delete the rest.\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n\n        if (oldFiber === null) {\n          // If we don't have any more existing children we can choose a fast path\n          // since the rest will all be insertions.\n          for (; newIdx < newChildren.length; newIdx++) {\n            var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n\n            if (!_newFiber) {\n              continue;\n            }\n\n            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              // TODO: Move out of the loop. This only happens for the first run.\n              resultingFirstChild = _newFiber;\n            } else {\n              previousNewFiber.sibling = _newFiber;\n            }\n\n            previousNewFiber = _newFiber;\n          }\n\n          return resultingFirstChild;\n        } // Add all children to a key map for quick lookups.\n\n\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n        for (; newIdx < newChildren.length; newIdx++) {\n          var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n\n          if (_newFiber2) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber2.alternate !== null) {\n                // The new fiber is a work in progress, but if there exists a\n                // current, that means that we reused the fiber. We need to delete\n                // it from the child list so that we don't add it to the deletion\n                // list.\n                existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n              }\n            }\n\n            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber2;\n            } else {\n              previousNewFiber.sibling = _newFiber2;\n            }\n\n            previousNewFiber = _newFiber2;\n          }\n        }\n\n        if (shouldTrackSideEffects) {\n          // Any existing children that weren't consumed above were deleted. We need\n          // to add them to the deletion list.\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n\n        return resultingFirstChild;\n      }\n\n      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n        // This is the same implementation as reconcileChildrenArray(),\n        // but using the iterator instead.\n        var iteratorFn = getIteratorFn(newChildrenIterable);\n        !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        {\n          // Warn about using Maps as children\n          if (typeof newChildrenIterable.entries === 'function') {\n            var possibleMap = newChildrenIterable;\n\n            if (possibleMap.entries === iteratorFn) {\n              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());\n              didWarnAboutMaps = true;\n            }\n          } // First, validate keys.\n          // We'll get a different iterator later for the main pass.\n\n\n          var _newChildren = iteratorFn.call(newChildrenIterable);\n\n          if (_newChildren) {\n            var knownKeys = null;\n\n            var _step = _newChildren.next();\n\n            for (; !_step.done; _step = _newChildren.next()) {\n              var child = _step.value;\n              knownKeys = warnOnInvalidKey(child, knownKeys);\n            }\n          }\n        }\n        var newChildren = iteratorFn.call(newChildrenIterable);\n        !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n        var step = newChildren.next();\n\n        for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n\n          var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n\n          if (newFiber === null) {\n            // TODO: This breaks on empty slots like null children. That's\n            // unfortunate because it triggers the slow path all the time. We need\n            // a better way to communicate whether this was a miss or null,\n            // boolean, undefined, etc.\n            if (!oldFiber) {\n              oldFiber = nextOldFiber;\n            }\n\n            break;\n          }\n\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              // We matched the slot, but we didn't reuse the existing fiber, so we\n              // need to delete the existing child.\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n          if (previousNewFiber === null) {\n            // TODO: Move out of the loop. This only happens for the first run.\n            resultingFirstChild = newFiber;\n          } else {\n            // TODO: Defer siblings if we're not at the right index for this slot.\n            // I.e. if we had null values before, then we want to defer this\n            // for each null value. However, we also don't want to call updateSlot\n            // with the previous one.\n            previousNewFiber.sibling = newFiber;\n          }\n\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n\n        if (step.done) {\n          // We've reached the end of the new children. We can delete the rest.\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n\n        if (oldFiber === null) {\n          // If we don't have any more existing children we can choose a fast path\n          // since the rest will all be insertions.\n          for (; !step.done; newIdx++, step = newChildren.next()) {\n            var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n\n            if (_newFiber3 === null) {\n              continue;\n            }\n\n            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              // TODO: Move out of the loop. This only happens for the first run.\n              resultingFirstChild = _newFiber3;\n            } else {\n              previousNewFiber.sibling = _newFiber3;\n            }\n\n            previousNewFiber = _newFiber3;\n          }\n\n          return resultingFirstChild;\n        } // Add all children to a key map for quick lookups.\n\n\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n        for (; !step.done; newIdx++, step = newChildren.next()) {\n          var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n\n          if (_newFiber4 !== null) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber4.alternate !== null) {\n                // The new fiber is a work in progress, but if there exists a\n                // current, that means that we reused the fiber. We need to delete\n                // it from the child list so that we don't add it to the deletion\n                // list.\n                existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n              }\n            }\n\n            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber4;\n            } else {\n              previousNewFiber.sibling = _newFiber4;\n            }\n\n            previousNewFiber = _newFiber4;\n          }\n        }\n\n        if (shouldTrackSideEffects) {\n          // Any existing children that weren't consumed above were deleted. We need\n          // to add them to the deletion list.\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n\n        return resultingFirstChild;\n      }\n\n      function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n        // There's no need to check for keys on text nodes since we don't have a\n        // way to define them.\n        if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n          // We already have an existing node so let's just update it and delete\n          // the rest.\n          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n          var existing = useFiber(currentFirstChild, textContent, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } // The existing first child is not a text node so we need to create one\n        // and delete the existing ones.\n\n\n        deleteRemainingChildren(returnFiber, currentFirstChild);\n        var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n        var key = element.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n              existing.ref = coerceRef(child, element);\n              existing['return'] = returnFiber;\n              {\n                existing._debugSource = element._source;\n                existing._debugOwner = element._owner;\n              }\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        if (element.type === REACT_FRAGMENT_TYPE) {\n          var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n\n          _created7.ref = coerceRef(currentFirstChild, element);\n          _created7['return'] = returnFiber;\n          return _created7;\n        }\n      }\n\n      function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {\n        var key = call.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === CallComponent) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, call, expirationTime);\n              existing['return'] = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {\n        // There's no need to check for keys on yields since they're stateless.\n        var child = currentFirstChild;\n\n        if (child !== null) {\n          if (child.tag === ReturnComponent) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            var existing = useFiber(child, null, expirationTime);\n            existing.type = returnNode.value;\n            existing['return'] = returnFiber;\n            return existing;\n          } else {\n            deleteRemainingChildren(returnFiber, child);\n          }\n        }\n\n        var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n        created.type = returnNode.value;\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n        var key = portal.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, portal.children || [], expirationTime);\n              existing['return'] = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      } // This API will tag the children with the side-effect of the reconciliation\n      // itself. They will be added to the side-effect list as we pass through the\n      // children and the parent.\n\n\n      function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n        // This function is not recursive.\n        // If the top level item is an array, we treat it as a set of children,\n        // not as a fragment. Nested arrays on the other hand will be treated as\n        // fragment nodes. Recursion happens at the normal flow.\n        // Handle top level unkeyed fragments as if they were arrays.\n        // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n        // We treat the ambiguous cases above the same.\n        if (ReactFeatureFlags.enableReactFragment && typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n          newChild = newChild.props.children;\n        } // Handle object types\n\n\n        var isObject = typeof newChild === 'object' && newChild !== null;\n\n        if (isObject) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n            case REACT_CALL_TYPE:\n              return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));\n\n            case REACT_RETURN_TYPE:\n              return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));\n\n            case REACT_PORTAL_TYPE:\n              return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n          }\n        }\n\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n        }\n\n        if (isArray$1(newChild)) {\n          return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n        }\n\n        if (getIteratorFn(newChild)) {\n          return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n        }\n\n        if (isObject) {\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n\n        if (typeof newChild === 'undefined') {\n          // If the new child is undefined, and the return fiber is a composite\n          // component, throw an error. If Fiber return types are disabled,\n          // we already threw above.\n          switch (returnFiber.tag) {\n            case ClassComponent:\n              {\n                {\n                  var instance = returnFiber.stateNode;\n\n                  if (instance.render._isMockFunction) {\n                    // We allow auto-mocks to proceed as if they're returning null.\n                    break;\n                  }\n                }\n              }\n            // Intentionally fall through to the next case, which handles both\n            // functions and classes\n            // eslint-disable-next-lined no-fallthrough\n\n            case FunctionalComponent:\n              {\n                var Component = returnFiber.type;\n                invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n              }\n          }\n        } // Remaining cases are all treated as empty.\n\n\n        return deleteRemainingChildren(returnFiber, currentFirstChild);\n      }\n\n      return reconcileChildFibers;\n    }\n\n    var reconcileChildFibers = ChildReconciler(true, true);\n    var reconcileChildFibersInPlace = ChildReconciler(false, true);\n    var mountChildFibersInPlace = ChildReconciler(false, false);\n\n    function cloneChildFibers(current, workInProgress) {\n      !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n      if (workInProgress.child === null) {\n        return;\n      }\n\n      var currentChild = workInProgress.child;\n      var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n      workInProgress.child = newChild;\n      newChild['return'] = workInProgress;\n\n      while (currentChild.sibling !== null) {\n        currentChild = currentChild.sibling;\n        newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n        newChild['return'] = workInProgress;\n      }\n\n      newChild.sibling = null;\n    }\n\n    var cancelWorkTimer = ReactDebugFiberPerf$1.cancelWorkTimer;\n    {\n      var warnedAboutStatelessRefs = {};\n    }\n\n    var ReactFiberBeginWork = function ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n      var shouldSetTextContent = config.shouldSetTextContent,\n          useSyncScheduling = config.useSyncScheduling,\n          shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n      var pushHostContext = hostContext.pushHostContext,\n          pushHostContainer = hostContext.pushHostContainer;\n      var enterHydrationState = hydrationContext.enterHydrationState,\n          resetHydrationState = hydrationContext.resetHydrationState,\n          tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n      var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n          adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n          constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n          mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n          updateClassInstance = _ReactFiberClassCompo.updateClassInstance; // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n\n      function reconcileChildren(current, workInProgress, nextChildren) {\n        reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n      }\n\n      function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n        if (current === null) {\n          // If this is a fresh new component that hasn't been rendered yet, we\n          // won't update its child set by applying minimal side-effects. Instead,\n          // we will add them all to the child before it gets rendered. That means\n          // we can optimize this reconciliation pass by not tracking side-effects.\n          workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n        } else if (current.child === workInProgress.child) {\n          // If the current child is the same as the work in progress, it means that\n          // we haven't yet started any work on these children. Therefore, we use\n          // the clone algorithm to create a copy of all the current children.\n          // If we had any progressed work already, that is invalid at this point so\n          // let's throw it out.\n          workInProgress.child = reconcileChildFibers(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n        } else {\n          // If, on the other hand, it is already using a clone, that means we've\n          // already begun some work on this tree and we can continue where we left\n          // off by reconciling against the existing children.\n          workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n        }\n      }\n\n      function updateFragment(current, workInProgress) {\n        var nextChildren = workInProgress.pendingProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextChildren === null) {\n            nextChildren = workInProgress.memoizedProps;\n          }\n        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextChildren);\n        return workInProgress.child;\n      }\n\n      function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n\n        if (ref !== null && (!current || current.ref !== ref)) {\n          // Schedule a Ref effect\n          workInProgress.effectTag |= Ref;\n        }\n      }\n\n      function updateFunctionalComponent(current, workInProgress) {\n        var fn = workInProgress.type;\n        var nextProps = workInProgress.pendingProps;\n        var memoizedProps = workInProgress.memoizedProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextProps === null) {\n            nextProps = memoizedProps;\n          }\n        } else {\n          if (nextProps === null || memoizedProps === nextProps) {\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          } // TODO: consider bringing fn.shouldComponentUpdate() back.\n          // It used to be here.\n\n        }\n\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var context = getMaskedContext(workInProgress, unmaskedContext);\n        var nextChildren;\n        {\n          ReactCurrentOwner.current = workInProgress;\n          ReactDebugCurrentFiber.setCurrentPhase('render');\n          nextChildren = fn(nextProps, context);\n          ReactDebugCurrentFiber.setCurrentPhase(null);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork;\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextProps);\n        return workInProgress.child;\n      }\n\n      function updateClassComponent(current, workInProgress, renderExpirationTime) {\n        // Push context providers early to prevent context stack mismatches.\n        // During mounting we don't know the child context yet as the instance doesn't exist.\n        // We will invalidate the child context in finishClassComponent() right after rendering.\n        var hasContext = pushContextProvider(workInProgress);\n        var shouldUpdate = void 0;\n\n        if (current === null) {\n          if (!workInProgress.stateNode) {\n            // In the initial pass we might need to construct the instance.\n            constructClassInstance(workInProgress, workInProgress.pendingProps);\n            mountClassInstance(workInProgress, renderExpirationTime);\n            shouldUpdate = true;\n          } else {\n            invariant(false, 'Resuming work not yet implemented.'); // In a resume, we'll already have an instance we can reuse.\n            // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n          }\n        } else {\n          shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n        }\n\n        return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n      }\n\n      function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n        // Refs should update even if shouldComponentUpdate returns false\n        markRef(current, workInProgress);\n\n        if (!shouldUpdate) {\n          // Context providers should defer to sCU for rendering\n          if (hasContext) {\n            invalidateContextProvider(workInProgress, false);\n          }\n\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var instance = workInProgress.stateNode; // Rerender\n\n        ReactCurrentOwner.current = workInProgress;\n        var nextChildren = void 0;\n        {\n          ReactDebugCurrentFiber.setCurrentPhase('render');\n          nextChildren = instance.render();\n          ReactDebugCurrentFiber.setCurrentPhase(null);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork;\n        reconcileChildren(current, workInProgress, nextChildren); // Memoize props and state using the values we just used to render.\n        // TODO: Restructure so we never read values from the instance.\n\n        memoizeState(workInProgress, instance.state);\n        memoizeProps(workInProgress, instance.props); // The context might have changed so we need to recalculate it.\n\n        if (hasContext) {\n          invalidateContextProvider(workInProgress, true);\n        }\n\n        return workInProgress.child;\n      }\n\n      function pushHostRootContext(workInProgress) {\n        var root = workInProgress.stateNode;\n\n        if (root.pendingContext) {\n          pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n        } else if (root.context) {\n          // Should always be set\n          pushTopLevelContextObject(workInProgress, root.context, false);\n        }\n\n        pushHostContainer(workInProgress, root.containerInfo);\n      }\n\n      function updateHostRoot(current, workInProgress, renderExpirationTime) {\n        pushHostRootContext(workInProgress);\n        var updateQueue = workInProgress.updateQueue;\n\n        if (updateQueue !== null) {\n          var prevState = workInProgress.memoizedState;\n          var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n\n          if (prevState === state) {\n            // If the state is the same as before, that's a bailout because we had\n            // no work that expires at this time.\n            resetHydrationState();\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n\n          var element = state.element;\n          var root = workInProgress.stateNode;\n\n          if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n            // If we don't have any current children this might be the first pass.\n            // We always try to hydrate. If this isn't a hydration pass there won't\n            // be any children to hydrate which is effectively the same thing as\n            // not hydrating.\n            // This is a bit of a hack. We track the host root as a placement to\n            // know that we're currently in a mounting state. That way isMounted\n            // works as expected. We must reset this before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag |= Placement; // Ensure that children mount into this root without tracking\n            // side-effects. This ensures that we don't store Placement effects on\n            // nodes that will be hydrated.\n\n            workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, element, renderExpirationTime);\n          } else {\n            // Otherwise reset hydration state in case we aborted and resumed another\n            // root.\n            resetHydrationState();\n            reconcileChildren(current, workInProgress, element);\n          }\n\n          memoizeState(workInProgress, state);\n          return workInProgress.child;\n        }\n\n        resetHydrationState(); // If there is no update queue, that's a bailout because the root has no props.\n\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n\n      function updateHostComponent(current, workInProgress, renderExpirationTime) {\n        pushHostContext(workInProgress);\n\n        if (current === null) {\n          tryToClaimNextHydratableInstance(workInProgress);\n        }\n\n        var type = workInProgress.type;\n        var memoizedProps = workInProgress.memoizedProps;\n        var nextProps = workInProgress.pendingProps;\n\n        if (nextProps === null) {\n          nextProps = memoizedProps;\n          !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        }\n\n        var prevProps = current !== null ? current.memoizedProps : null;\n\n        if (hasContextChanged()) {// Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n        } else if (nextProps === null || memoizedProps === nextProps) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var nextChildren = nextProps.children;\n        var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n        if (isDirectTextChild) {\n          // We special case a direct text child of a host node. This is a common\n          // case. We won't handle it as a reified child. We will instead handle\n          // this in the host environment that also have access to this prop. That\n          // avoids allocating another HostText fiber and traversing it.\n          nextChildren = null;\n        } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n          // If we're switching from a direct text child to a normal child, or to\n          // empty, we need to schedule the text content to be reset.\n          workInProgress.effectTag |= ContentReset;\n        }\n\n        markRef(current, workInProgress); // Check the host config to see if the children are offscreen/hidden.\n\n        if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n          // Down-prioritize the children.\n          workInProgress.expirationTime = Never; // Bailout and come back to this fiber later.\n\n          return null;\n        }\n\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextProps);\n        return workInProgress.child;\n      }\n\n      function updateHostText(current, workInProgress) {\n        if (current === null) {\n          tryToClaimNextHydratableInstance(workInProgress);\n        }\n\n        var nextProps = workInProgress.pendingProps;\n\n        if (nextProps === null) {\n          nextProps = workInProgress.memoizedProps;\n        }\n\n        memoizeProps(workInProgress, nextProps); // Nothing to do here. This is terminal. We'll do the completion step\n        // immediately after.\n\n        return null;\n      }\n\n      function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n        !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var fn = workInProgress.type;\n        var props = workInProgress.pendingProps;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var context = getMaskedContext(workInProgress, unmaskedContext);\n        var value;\n        {\n          if (fn.prototype && typeof fn.prototype.render === 'function') {\n            var componentName = getComponentName(workInProgress);\n            warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n          }\n\n          ReactCurrentOwner.current = workInProgress;\n          value = fn(props, context);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork;\n\n        if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n          // Proceed under the assumption that this is a class instance\n          workInProgress.tag = ClassComponent; // Push context providers early to prevent context stack mismatches.\n          // During mounting we don't know the child context yet as the instance doesn't exist.\n          // We will invalidate the child context in finishClassComponent() right after rendering.\n\n          var hasContext = pushContextProvider(workInProgress);\n          adoptClassInstance(workInProgress, value);\n          mountClassInstance(workInProgress, renderExpirationTime);\n          return finishClassComponent(current, workInProgress, true, hasContext);\n        } else {\n          // Proceed under the assumption that this is a functional component\n          workInProgress.tag = FunctionalComponent;\n          {\n            var Component = workInProgress.type;\n\n            if (Component) {\n              warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n            }\n\n            if (workInProgress.ref !== null) {\n              var info = '';\n              var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n\n              if (ownerName) {\n                info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n              }\n\n              var warningKey = ownerName || workInProgress._debugID || '';\n              var debugSource = workInProgress._debugSource;\n\n              if (debugSource) {\n                warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n              }\n\n              if (!warnedAboutStatelessRefs[warningKey]) {\n                warnedAboutStatelessRefs[warningKey] = true;\n                warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n              }\n            }\n          }\n          reconcileChildren(current, workInProgress, value);\n          memoizeProps(workInProgress, props);\n          return workInProgress.child;\n        }\n      }\n\n      function updateCallComponent(current, workInProgress, renderExpirationTime) {\n        var nextCall = workInProgress.pendingProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextCall === null) {\n            nextCall = current && current.memoizedProps;\n            !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          }\n        } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {\n          nextCall = workInProgress.memoizedProps; // TODO: When bailing out, we might need to return the stateNode instead\n          // of the child. To check it for work.\n          // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var nextChildren = nextCall.children; // The following is a fork of reconcileChildrenAtExpirationTime but using\n        // stateNode to store the child.\n\n        if (current === null) {\n          workInProgress.stateNode = mountChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        } else if (current.child === workInProgress.child) {\n          workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        } else {\n          workInProgress.stateNode = reconcileChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        }\n\n        memoizeProps(workInProgress, nextCall); // This doesn't take arbitrary time so we could synchronously just begin\n        // eagerly do the work of workInProgress.child as an optimization.\n\n        return workInProgress.stateNode;\n      }\n\n      function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        var nextChildren = workInProgress.pendingProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextChildren === null) {\n            nextChildren = current && current.memoizedProps;\n            !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          }\n        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        if (current === null) {\n          // Portals are special because we don't append the children during mount\n          // but at commit. Therefore we need to track insertions which the normal\n          // flow doesn't do during mount. This doesn't happen at the root because\n          // the root always starts with a \"current\" with a null child.\n          // TODO: Consider unifying this with how the root works.\n          workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n          memoizeProps(workInProgress, nextChildren);\n        } else {\n          reconcileChildren(current, workInProgress, nextChildren);\n          memoizeProps(workInProgress, nextChildren);\n        }\n\n        return workInProgress.child;\n      }\n      /*\n      function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n        let child = firstChild;\n        do {\n          // Ensure that the first and last effect of the parent corresponds\n          // to the children's first and last effect.\n          if (!returnFiber.firstEffect) {\n            returnFiber.firstEffect = child.firstEffect;\n          }\n          if (child.lastEffect) {\n            if (returnFiber.lastEffect) {\n              returnFiber.lastEffect.nextEffect = child.firstEffect;\n            }\n            returnFiber.lastEffect = child.lastEffect;\n          }\n        } while (child = child.sibling);\n      }\n      */\n\n\n      function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n        {\n          cancelWorkTimer(workInProgress);\n        } // TODO: We should ideally be able to bail out early if the children have no\n        // more work to do. However, since we don't have a separation of this\n        // Fiber's priority and its children yet - we don't know without doing lots\n        // of the same work we do anyway. Once we have that separation we can just\n        // bail out here if the children has no more work at this priority level.\n        // if (workInProgress.priorityOfChildren <= priorityLevel) {\n        //   // If there are side-effects in these children that have not yet been\n        //   // committed we need to ensure that they get properly transferred up.\n        //   if (current && current.child !== workInProgress.child) {\n        //     reuseChildrenEffects(workInProgress, child);\n        //   }\n        //   return null;\n        // }\n\n        cloneChildFibers(current, workInProgress);\n        return workInProgress.child;\n      }\n\n      function bailoutOnLowPriority(current, workInProgress) {\n        {\n          cancelWorkTimer(workInProgress);\n        } // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n        // See PR 8590 discussion for context\n\n        switch (workInProgress.tag) {\n          case HostRoot:\n            pushHostRootContext(workInProgress);\n            break;\n\n          case ClassComponent:\n            pushContextProvider(workInProgress);\n            break;\n\n          case HostPortal:\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            break;\n        } // TODO: What if this is currently in progress?\n        // How can that happen? How is this not being cloned?\n\n\n        return null;\n      } // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n\n\n      function memoizeProps(workInProgress, nextProps) {\n        workInProgress.memoizedProps = nextProps;\n      }\n\n      function memoizeState(workInProgress, nextState) {\n        workInProgress.memoizedState = nextState; // Don't reset the updateQueue, in case there are pending updates. Resetting\n        // is handled by processUpdateQueue.\n      }\n\n      function beginWork(current, workInProgress, renderExpirationTime) {\n        if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n          return bailoutOnLowPriority(current, workInProgress);\n        }\n\n        switch (workInProgress.tag) {\n          case IndeterminateComponent:\n            return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n\n          case FunctionalComponent:\n            return updateFunctionalComponent(current, workInProgress);\n\n          case ClassComponent:\n            return updateClassComponent(current, workInProgress, renderExpirationTime);\n\n          case HostRoot:\n            return updateHostRoot(current, workInProgress, renderExpirationTime);\n\n          case HostComponent:\n            return updateHostComponent(current, workInProgress, renderExpirationTime);\n\n          case HostText:\n            return updateHostText(current, workInProgress);\n\n          case CallHandlerPhase:\n            // This is a restart. Reset the tag to the initial phase.\n            workInProgress.tag = CallComponent;\n          // Intentionally fall through since this is now the same.\n\n          case CallComponent:\n            return updateCallComponent(current, workInProgress, renderExpirationTime);\n\n          case ReturnComponent:\n            // A return component is just a placeholder, we can just run through the\n            // next one immediately.\n            return null;\n\n          case HostPortal:\n            return updatePortalComponent(current, workInProgress, renderExpirationTime);\n\n          case Fragment:\n            return updateFragment(current, workInProgress);\n\n          default:\n            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      function beginFailedWork(current, workInProgress, renderExpirationTime) {\n        // Push context providers here to avoid a push/pop context mismatch.\n        switch (workInProgress.tag) {\n          case ClassComponent:\n            pushContextProvider(workInProgress);\n            break;\n\n          case HostRoot:\n            pushHostRootContext(workInProgress);\n            break;\n\n          default:\n            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n        } // Add an error effect so we can handle the error during the commit phase\n\n\n        workInProgress.effectTag |= Err; // This is a weird case where we do \"resume\" work — work that failed on\n        // our first attempt. Because we no longer have a notion of \"progressed\n        // deletions,\" reset the child to the current child to make sure we delete\n        // it again. TODO: Find a better way to handle this, perhaps during a more\n        // general overhaul of error handling.\n\n        if (current === null) {\n          workInProgress.child = null;\n        } else if (workInProgress.child !== current.child) {\n          workInProgress.child = current.child;\n        }\n\n        if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n          return bailoutOnLowPriority(current, workInProgress);\n        } // If we don't bail out, we're going be recomputing our children so we need\n        // to drop our effect list.\n\n\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null; // Unmount the current children as if the component rendered null\n\n        var nextChildren = null;\n        reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n\n        if (workInProgress.tag === ClassComponent) {\n          var instance = workInProgress.stateNode;\n          workInProgress.memoizedProps = instance.props;\n          workInProgress.memoizedState = instance.state;\n        }\n\n        return workInProgress.child;\n      }\n\n      return {\n        beginWork: beginWork,\n        beginFailedWork: beginFailedWork\n      };\n    };\n\n    var ReactFiberCompleteWork = function ReactFiberCompleteWork(config, hostContext, hydrationContext) {\n      var createInstance = config.createInstance,\n          createTextInstance = config.createTextInstance,\n          appendInitialChild = config.appendInitialChild,\n          finalizeInitialChildren = config.finalizeInitialChildren,\n          prepareUpdate = config.prepareUpdate,\n          mutation = config.mutation,\n          persistence = config.persistence;\n      var getRootHostContainer = hostContext.getRootHostContainer,\n          popHostContext = hostContext.popHostContext,\n          getHostContext = hostContext.getHostContext,\n          popHostContainer = hostContext.popHostContainer;\n      var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n          prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n          popHydrationState = hydrationContext.popHydrationState;\n\n      function markUpdate(workInProgress) {\n        // Tag the fiber with an update effect. This turns a Placement into\n        // an UpdateAndPlacement.\n        workInProgress.effectTag |= Update;\n      }\n\n      function markRef(workInProgress) {\n        workInProgress.effectTag |= Ref;\n      }\n\n      function appendAllReturns(returns, workInProgress) {\n        var node = workInProgress.stateNode;\n\n        if (node) {\n          node['return'] = workInProgress;\n        }\n\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n            invariant(false, 'A call cannot have host component children.');\n          } else if (node.tag === ReturnComponent) {\n            returns.push(node.type);\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n        var call = workInProgress.memoizedProps;\n        !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0; // First step of the call has completed. Now we need to do the second.\n        // TODO: It would be nice to have a multi stage call represented by a\n        // single component, or at least tail call optimize nested ones. Currently\n        // that requires additional fields that we don't want to add to the fiber.\n        // So this requires nested handlers.\n        // Note: This doesn't mutate the alternate node. I don't think it needs to\n        // since this stage is reset for every pass.\n\n        workInProgress.tag = CallHandlerPhase; // Build up the returns.\n        // TODO: Compare this to a generator or opaque helpers like Children.\n\n        var returns = [];\n        appendAllReturns(returns, workInProgress);\n        var fn = call.handler;\n        var props = call.props;\n        var nextChildren = fn(props, returns);\n        var currentFirstChild = current !== null ? current.child : null;\n        workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n        return workInProgress.child;\n      }\n\n      function appendAllChildren(parent, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendInitialChild(parent, node.stateNode);\n          } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === workInProgress) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      var updateHostContainer = void 0;\n      var updateHostComponent = void 0;\n      var updateHostText = void 0;\n\n      if (mutation) {\n        if (ReactFeatureFlags.enableMutatingReconciler) {\n          // Mutation mode\n          updateHostContainer = function updateHostContainer(workInProgress) {// Noop\n          };\n\n          updateHostComponent = function updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n            // TODO: Type this specific to this type of component.\n            workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n            // is a new ref we mark this as an update. All the work is done in commitWork.\n\n            if (updatePayload) {\n              markUpdate(workInProgress);\n            }\n          };\n\n          updateHostText = function updateHostText(current, workInProgress, oldText, newText) {\n            // If the text differs, mark it as an update. All the work in done in commitWork.\n            if (oldText !== newText) {\n              markUpdate(workInProgress);\n            }\n          };\n        } else {\n          invariant(false, 'Mutating reconciler is disabled.');\n        }\n      } else if (persistence) {\n        if (ReactFeatureFlags.enablePersistentReconciler) {\n          // Persistent host tree mode\n          var cloneInstance = persistence.cloneInstance,\n              createContainerChildSet = persistence.createContainerChildSet,\n              appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n              finalizeContainerChildren = persistence.finalizeContainerChildren; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n          var appendAllChildrenToContainer = function appendAllChildrenToContainer(containerChildSet, workInProgress) {\n            // We only have the top Fiber that was created but we need recurse down its\n            // children to find all the terminal nodes.\n            var node = workInProgress.child;\n\n            while (node !== null) {\n              if (node.tag === HostComponent || node.tag === HostText) {\n                appendChildToContainerChildSet(containerChildSet, node.stateNode);\n              } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n                // down its children. Instead, we'll get insertions from each child in\n                // the portal directly.\n              } else if (node.child !== null) {\n                node.child['return'] = node;\n                node = node.child;\n                continue;\n              }\n\n              if (node === workInProgress) {\n                return;\n              }\n\n              while (node.sibling === null) {\n                if (node['return'] === null || node['return'] === workInProgress) {\n                  return;\n                }\n\n                node = node['return'];\n              }\n\n              node.sibling['return'] = node['return'];\n              node = node.sibling;\n            }\n          };\n\n          updateHostContainer = function updateHostContainer(workInProgress) {\n            var portalOrRoot = workInProgress.stateNode;\n            var childrenUnchanged = workInProgress.firstEffect === null;\n\n            if (childrenUnchanged) {// No changes, just reuse the existing instance.\n            } else {\n              var container = portalOrRoot.containerInfo;\n              var newChildSet = createContainerChildSet(container);\n\n              if (finalizeContainerChildren(container, newChildSet)) {\n                markUpdate(workInProgress);\n              }\n\n              portalOrRoot.pendingChildren = newChildSet; // If children might have changed, we have to add them all to the set.\n\n              appendAllChildrenToContainer(newChildSet, workInProgress); // Schedule an update on the container to swap out the container.\n\n              markUpdate(workInProgress);\n            }\n          };\n\n          updateHostComponent = function updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n            // If there are no effects associated with this node, then none of our children had any updates.\n            // This guarantees that we can reuse all of them.\n            var childrenUnchanged = workInProgress.firstEffect === null;\n            var currentInstance = current.stateNode;\n\n            if (childrenUnchanged && updatePayload === null) {\n              // No changes, just reuse the existing instance.\n              // Note that this might release a previous clone.\n              workInProgress.stateNode = currentInstance;\n            } else {\n              var recyclableInstance = workInProgress.stateNode;\n              var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n              if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {\n                markUpdate(workInProgress);\n              }\n\n              workInProgress.stateNode = newInstance;\n\n              if (childrenUnchanged) {\n                // If there are no other effects in this tree, we need to flag this node as having one.\n                // Even though we're not going to use it for anything.\n                // Otherwise parents won't know that there are new children to propagate upwards.\n                markUpdate(workInProgress);\n              } else {\n                // If children might have changed, we have to add them all to the set.\n                appendAllChildren(newInstance, workInProgress);\n              }\n            }\n          };\n\n          updateHostText = function updateHostText(current, workInProgress, oldText, newText) {\n            if (oldText !== newText) {\n              // If the text content differs, we'll create a new text instance for it.\n              var rootContainerInstance = getRootHostContainer();\n              var currentHostContext = getHostContext();\n              workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n              // This lets the parents know that at least one of their children has changed.\n\n              markUpdate(workInProgress);\n            }\n          };\n        } else {\n          invariant(false, 'Persistent reconciler is disabled.');\n        }\n      } else {\n        if (ReactFeatureFlags.enableNoopReconciler) {\n          // No host operations\n          updateHostContainer = function updateHostContainer(workInProgress) {// Noop\n          };\n\n          updateHostComponent = function updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {// Noop\n          };\n\n          updateHostText = function updateHostText(current, workInProgress, oldText, newText) {// Noop\n          };\n        } else {\n          invariant(false, 'Noop reconciler is disabled.');\n        }\n      }\n\n      function completeWork(current, workInProgress, renderExpirationTime) {\n        // Get the latest props.\n        var newProps = workInProgress.pendingProps;\n\n        if (newProps === null) {\n          newProps = workInProgress.memoizedProps;\n        } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {\n          // Reset the pending props, unless this was a down-prioritization.\n          workInProgress.pendingProps = null;\n        }\n\n        switch (workInProgress.tag) {\n          case FunctionalComponent:\n            return null;\n\n          case ClassComponent:\n            {\n              // We are leaving this subtree, so pop context if any.\n              popContextProvider(workInProgress);\n              return null;\n            }\n\n          case HostRoot:\n            {\n              popHostContainer(workInProgress);\n              popTopLevelContextObject(workInProgress);\n              var fiberRoot = workInProgress.stateNode;\n\n              if (fiberRoot.pendingContext) {\n                fiberRoot.context = fiberRoot.pendingContext;\n                fiberRoot.pendingContext = null;\n              }\n\n              if (current === null || current.child === null) {\n                // If we hydrated, pop so that we can delete any remaining children\n                // that weren't hydrated.\n                popHydrationState(workInProgress); // This resets the hacky state to fix isMounted before committing.\n                // TODO: Delete this when we delete isMounted and findDOMNode.\n\n                workInProgress.effectTag &= ~Placement;\n              }\n\n              updateHostContainer(workInProgress);\n              return null;\n            }\n\n          case HostComponent:\n            {\n              popHostContext(workInProgress);\n              var rootContainerInstance = getRootHostContainer();\n              var type = workInProgress.type;\n\n              if (current !== null && workInProgress.stateNode != null) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps; // If we get updated because one of our children updated, we don't\n                // have newProps so we'll have to reuse them.\n                // TODO: Split the update API as separate for the props vs. children.\n                // Even better would be if children weren't special cased at all tho.\n\n                var instance = workInProgress.stateNode;\n                var currentHostContext = getHostContext();\n                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n                updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);\n\n                if (current.ref !== workInProgress.ref) {\n                  markRef(workInProgress);\n                }\n              } else {\n                if (!newProps) {\n                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0; // This can happen when we abort work.\n\n                  return null;\n                }\n\n                var _currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                // \"stack\" as the parent. Then append children as we go in beginWork\n                // or completeWork depending on we want to add then top->down or\n                // bottom->up. Top->down is faster in IE11.\n\n\n                var wasHydrated = popHydrationState(workInProgress);\n\n                if (wasHydrated) {\n                  // TODO: Move this and createInstance step into the beginPhase\n                  // to consolidate.\n                  if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                    // If changes to the hydrated node needs to be applied at the\n                    // commit-phase we mark this as such.\n                    markUpdate(workInProgress);\n                  }\n                } else {\n                  var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n                  appendAllChildren(_instance, workInProgress); // Certain renderers require commit-time effects for initial mount.\n                  // (eg DOM renderer supports auto-focus for certain elements).\n                  // Make sure such renderers get scheduled for later work.\n\n                  if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                    markUpdate(workInProgress);\n                  }\n\n                  workInProgress.stateNode = _instance;\n                }\n\n                if (workInProgress.ref !== null) {\n                  // If there is a ref on a host node we need to schedule a callback\n                  markRef(workInProgress);\n                }\n              }\n\n              return null;\n            }\n\n          case HostText:\n            {\n              var newText = newProps;\n\n              if (current && workInProgress.stateNode != null) {\n                var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                // to schedule a side-effect to do the updates.\n\n                updateHostText(current, workInProgress, oldText, newText);\n              } else {\n                if (typeof newText !== 'string') {\n                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0; // This can happen when we abort work.\n\n                  return null;\n                }\n\n                var _rootContainerInstance = getRootHostContainer();\n\n                var _currentHostContext2 = getHostContext();\n\n                var _wasHydrated = popHydrationState(workInProgress);\n\n                if (_wasHydrated) {\n                  if (prepareToHydrateHostTextInstance(workInProgress)) {\n                    markUpdate(workInProgress);\n                  }\n                } else {\n                  workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n                }\n              }\n\n              return null;\n            }\n\n          case CallComponent:\n            return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n\n          case CallHandlerPhase:\n            // Reset the tag to now be a first phase call.\n            workInProgress.tag = CallComponent;\n            return null;\n\n          case ReturnComponent:\n            // Does nothing.\n            return null;\n\n          case Fragment:\n            return null;\n\n          case HostPortal:\n            popHostContainer(workInProgress);\n            updateHostContainer(workInProgress);\n            return null;\n          // Error cases\n\n          case IndeterminateComponent:\n            invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n          // eslint-disable-next-line no-fallthrough\n\n          default:\n            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      return {\n        completeWork: completeWork\n      };\n    };\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var onCommitFiberRoot = null;\n    var onCommitFiberUnmount = null;\n\n    function onCommitRoot(root) {\n      if (typeof onCommitFiberRoot === 'function') {\n        onCommitFiberRoot(root);\n      }\n    }\n\n    function onCommitUnmount(fiber) {\n      if (typeof onCommitFiberUnmount === 'function') {\n        onCommitFiberUnmount(fiber);\n      }\n    }\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\n    var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\n    var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n    var startPhaseTimer$2 = ReactDebugFiberPerf$1.startPhaseTimer;\n    var stopPhaseTimer$2 = ReactDebugFiberPerf$1.stopPhaseTimer;\n\n    var ReactFiberCommitWork = function ReactFiberCommitWork(config, captureError) {\n      var getPublicInstance = config.getPublicInstance,\n          mutation = config.mutation,\n          persistence = config.persistence;\n      {\n        var callComponentWillUnmountWithTimerInDev = function callComponentWillUnmountWithTimerInDev(current, instance) {\n          startPhaseTimer$2(current, 'componentWillUnmount');\n          instance.props = current.memoizedProps;\n          instance.state = current.memoizedState;\n          instance.componentWillUnmount();\n          stopPhaseTimer$2();\n        };\n      } // Capture errors so they don't interrupt unmounting.\n\n      function safelyCallComponentWillUnmount(current, instance) {\n        {\n          invokeGuardedCallback$2(null, callComponentWillUnmountWithTimerInDev, null, current, instance);\n\n          if (hasCaughtError$1()) {\n            var unmountError = clearCaughtError$1();\n            captureError(current, unmountError);\n          }\n        }\n      }\n\n      function safelyDetachRef(current) {\n        var ref = current.ref;\n\n        if (ref !== null) {\n          {\n            invokeGuardedCallback$2(null, ref, null, null);\n\n            if (hasCaughtError$1()) {\n              var refError = clearCaughtError$1();\n              captureError(current, refError);\n            }\n          }\n        }\n      }\n\n      function commitLifeCycles(current, finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              var instance = finishedWork.stateNode;\n\n              if (finishedWork.effectTag & Update) {\n                if (current === null) {\n                  {\n                    startPhaseTimer$2(finishedWork, 'componentDidMount');\n                  }\n                  instance.props = finishedWork.memoizedProps;\n                  instance.state = finishedWork.memoizedState;\n                  instance.componentDidMount();\n                  {\n                    stopPhaseTimer$2();\n                  }\n                } else {\n                  var prevProps = current.memoizedProps;\n                  var prevState = current.memoizedState;\n                  {\n                    startPhaseTimer$2(finishedWork, 'componentDidUpdate');\n                  }\n                  instance.props = finishedWork.memoizedProps;\n                  instance.state = finishedWork.memoizedState;\n                  instance.componentDidUpdate(prevProps, prevState);\n                  {\n                    stopPhaseTimer$2();\n                  }\n                }\n              }\n\n              var updateQueue = finishedWork.updateQueue;\n\n              if (updateQueue !== null) {\n                commitCallbacks(updateQueue, instance);\n              }\n\n              return;\n            }\n\n          case HostRoot:\n            {\n              var _updateQueue = finishedWork.updateQueue;\n\n              if (_updateQueue !== null) {\n                var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;\n\n                commitCallbacks(_updateQueue, _instance);\n              }\n\n              return;\n            }\n\n          case HostComponent:\n            {\n              var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n              // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n              // These effects should only be committed when components are first mounted,\n              // aka when there is no current/alternate.\n\n              if (current === null && finishedWork.effectTag & Update) {\n                var type = finishedWork.type;\n                var props = finishedWork.memoizedProps;\n                commitMount(_instance2, type, props, finishedWork);\n              }\n\n              return;\n            }\n\n          case HostText:\n            {\n              // We have no life-cycles associated with text.\n              return;\n            }\n\n          case HostPortal:\n            {\n              // We have no life-cycles associated with portals.\n              return;\n            }\n\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      }\n\n      function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n\n        if (ref !== null) {\n          var instance = finishedWork.stateNode;\n\n          switch (finishedWork.tag) {\n            case HostComponent:\n              ref(getPublicInstance(instance));\n              break;\n\n            default:\n              ref(instance);\n          }\n        }\n      }\n\n      function commitDetachRef(current) {\n        var currentRef = current.ref;\n\n        if (currentRef !== null) {\n          currentRef(null);\n        }\n      } // User-originating errors (lifecycles and refs) should not interrupt\n      // deletion, so don't let them throw. Host-originating errors should\n      // interrupt deletion, so it's okay\n\n\n      function commitUnmount(current) {\n        if (typeof onCommitUnmount === 'function') {\n          onCommitUnmount(current);\n        }\n\n        switch (current.tag) {\n          case ClassComponent:\n            {\n              safelyDetachRef(current);\n              var instance = current.stateNode;\n\n              if (typeof instance.componentWillUnmount === 'function') {\n                safelyCallComponentWillUnmount(current, instance);\n              }\n\n              return;\n            }\n\n          case HostComponent:\n            {\n              safelyDetachRef(current);\n              return;\n            }\n\n          case CallComponent:\n            {\n              commitNestedUnmounts(current.stateNode);\n              return;\n            }\n\n          case HostPortal:\n            {\n              // TODO: this is recursive.\n              // We are also not using this parent because\n              // the portal will get pushed immediately.\n              if (ReactFeatureFlags.enableMutatingReconciler && mutation) {\n                unmountHostComponents(current);\n              } else if (ReactFeatureFlags.enablePersistentReconciler && persistence) {\n                emptyPortalContainer(current);\n              }\n\n              return;\n            }\n        }\n      }\n\n      function commitNestedUnmounts(root) {\n        // While we're inside a removed host node we don't want to call\n        // removeChild on the inner nodes because they're removed by the top\n        // call anyway. We also want to call componentWillUnmount on all\n        // composites before this host node is removed from the tree. Therefore\n        var node = root;\n\n        while (true) {\n          commitUnmount(node); // Visit children because they may contain more composite or host nodes.\n          // Skip portals because commitUnmount() currently visits them recursively.\n\n          if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.\n          // If we don't use mutation we drill down into portals here instead.\n          !mutation || node.tag !== HostPortal)) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === root) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === root) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function detachFiber(current) {\n        // Cut off the return pointers to disconnect it from the tree. Ideally, we\n        // should clear the child pointer of the parent alternate to let this\n        // get GC:ed but we don't know which for sure which parent is the current\n        // one so we'll settle for GC:ing the subtree of this child. This child\n        // itself will be GC:ed when the parent updates the next time.\n        current['return'] = null;\n        current.child = null;\n\n        if (current.alternate) {\n          current.alternate.child = null;\n          current.alternate['return'] = null;\n        }\n      }\n\n      if (!mutation) {\n        var commitContainer = void 0;\n\n        if (persistence) {\n          var replaceContainerChildren = persistence.replaceContainerChildren,\n              createContainerChildSet = persistence.createContainerChildSet;\n\n          var emptyPortalContainer = function emptyPortalContainer(current) {\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet(containerInfo);\n            replaceContainerChildren(containerInfo, emptyChildSet);\n          };\n\n          commitContainer = function commitContainer(finishedWork) {\n            switch (finishedWork.tag) {\n              case ClassComponent:\n                {\n                  return;\n                }\n\n              case HostComponent:\n                {\n                  return;\n                }\n\n              case HostText:\n                {\n                  return;\n                }\n\n              case HostRoot:\n              case HostPortal:\n                {\n                  var portalOrRoot = finishedWork.stateNode;\n                  var containerInfo = portalOrRoot.containerInfo,\n                      _pendingChildren = portalOrRoot.pendingChildren;\n                  replaceContainerChildren(containerInfo, _pendingChildren);\n                  return;\n                }\n\n              default:\n                {\n                  invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n                }\n            }\n          };\n        } else {\n          commitContainer = function commitContainer(finishedWork) {// Noop\n          };\n        }\n\n        if (ReactFeatureFlags.enablePersistentReconciler || ReactFeatureFlags.enableNoopReconciler) {\n          return {\n            commitResetTextContent: function commitResetTextContent(finishedWork) {},\n            commitPlacement: function commitPlacement(finishedWork) {},\n            commitDeletion: function commitDeletion(current) {\n              // Detach refs and call componentWillUnmount() on the whole subtree.\n              commitNestedUnmounts(current);\n              detachFiber(current);\n            },\n            commitWork: function commitWork(current, finishedWork) {\n              commitContainer(finishedWork);\n            },\n            commitLifeCycles: commitLifeCycles,\n            commitAttachRef: commitAttachRef,\n            commitDetachRef: commitDetachRef\n          };\n        } else if (persistence) {\n          invariant(false, 'Persistent reconciler is disabled.');\n        } else {\n          invariant(false, 'Noop reconciler is disabled.');\n        }\n      }\n\n      var commitMount = mutation.commitMount,\n          commitUpdate = mutation.commitUpdate,\n          resetTextContent = mutation.resetTextContent,\n          commitTextUpdate = mutation.commitTextUpdate,\n          appendChild = mutation.appendChild,\n          appendChildToContainer = mutation.appendChildToContainer,\n          insertBefore = mutation.insertBefore,\n          insertInContainerBefore = mutation.insertInContainerBefore,\n          removeChild = mutation.removeChild,\n          removeChildFromContainer = mutation.removeChildFromContainer;\n\n      function getHostParentFiber(fiber) {\n        var parent = fiber['return'];\n\n        while (parent !== null) {\n          if (isHostParent(parent)) {\n            return parent;\n          }\n\n          parent = parent['return'];\n        }\n\n        invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n      }\n\n      function isHostParent(fiber) {\n        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n      }\n\n      function getHostSibling(fiber) {\n        // We're going to search forward into the tree until we find a sibling host\n        // node. Unfortunately, if multiple insertions are done in a row we have to\n        // search past them. This leads to exponential search for the next sibling.\n        var node = fiber;\n\n        siblings: while (true) {\n          // If we didn't find anything, let's try the next sibling.\n          while (node.sibling === null) {\n            if (node['return'] === null || isHostParent(node['return'])) {\n              // If we pop out of the root or hit the parent the fiber we are the\n              // last sibling.\n              return null;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n\n          while (node.tag !== HostComponent && node.tag !== HostText) {\n            // If it is not host node and, we might have a host node inside it.\n            // Try to search down until we find one.\n            if (node.effectTag & Placement) {\n              // If we don't have a child, try the siblings instead.\n              continue siblings;\n            } // If we don't have a child, try the siblings instead.\n            // We also skip portals because they are not part of this host tree.\n\n\n            if (node.child === null || node.tag === HostPortal) {\n              continue siblings;\n            } else {\n              node.child['return'] = node;\n              node = node.child;\n            }\n          } // Check if this host node is stable or about to be placed.\n\n\n          if (!(node.effectTag & Placement)) {\n            // Found it!\n            return node.stateNode;\n          }\n        }\n      }\n\n      function commitPlacement(finishedWork) {\n        // Recursively insert all host nodes into the parent.\n        var parentFiber = getHostParentFiber(finishedWork);\n        var parent = void 0;\n        var isContainer = void 0;\n\n        switch (parentFiber.tag) {\n          case HostComponent:\n            parent = parentFiber.stateNode;\n            isContainer = false;\n            break;\n\n          case HostRoot:\n            parent = parentFiber.stateNode.containerInfo;\n            isContainer = true;\n            break;\n\n          case HostPortal:\n            parent = parentFiber.stateNode.containerInfo;\n            isContainer = true;\n            break;\n\n          default:\n            invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n        }\n\n        if (parentFiber.effectTag & ContentReset) {\n          // Reset the text content of the parent before doing any insertions\n          resetTextContent(parent); // Clear ContentReset from the effect tag\n\n          parentFiber.effectTag &= ~ContentReset;\n        }\n\n        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need recurse down its\n        // children to find all the terminal nodes.\n\n        var node = finishedWork;\n\n        while (true) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            if (before) {\n              if (isContainer) {\n                insertInContainerBefore(parent, node.stateNode, before);\n              } else {\n                insertBefore(parent, node.stateNode, before);\n              }\n            } else {\n              if (isContainer) {\n                appendChildToContainer(parent, node.stateNode);\n              } else {\n                appendChild(parent, node.stateNode);\n              }\n            }\n          } else if (node.tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === finishedWork) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === finishedWork) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function unmountHostComponents(current) {\n        // We only have the top Fiber that was inserted but we need recurse down its\n        var node = current; // Each iteration, currentParent is populated with node's host parent if not\n        // currentParentIsValid.\n\n        var currentParentIsValid = false;\n        var currentParent = void 0;\n        var currentParentIsContainer = void 0;\n\n        while (true) {\n          if (!currentParentIsValid) {\n            var parent = node['return'];\n\n            findParent: while (true) {\n              !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n              switch (parent.tag) {\n                case HostComponent:\n                  currentParent = parent.stateNode;\n                  currentParentIsContainer = false;\n                  break findParent;\n\n                case HostRoot:\n                  currentParent = parent.stateNode.containerInfo;\n                  currentParentIsContainer = true;\n                  break findParent;\n\n                case HostPortal:\n                  currentParent = parent.stateNode.containerInfo;\n                  currentParentIsContainer = true;\n                  break findParent;\n              }\n\n              parent = parent['return'];\n            }\n\n            currentParentIsValid = true;\n          }\n\n          if (node.tag === HostComponent || node.tag === HostText) {\n            commitNestedUnmounts(node); // After all the children have unmounted, it is now safe to remove the\n            // node from the tree.\n\n            if (currentParentIsContainer) {\n              removeChildFromContainer(currentParent, node.stateNode);\n            } else {\n              removeChild(currentParent, node.stateNode);\n            } // Don't visit children because we already visited them.\n\n          } else if (node.tag === HostPortal) {\n            // When we go into a portal, it becomes the parent to remove from.\n            // We will reassign it back when we pop the portal on the way up.\n            currentParent = node.stateNode.containerInfo; // Visit children because portals might contain host components.\n\n            if (node.child !== null) {\n              node.child['return'] = node;\n              node = node.child;\n              continue;\n            }\n          } else {\n            commitUnmount(node); // Visit children because we may find more host components below.\n\n            if (node.child !== null) {\n              node.child['return'] = node;\n              node = node.child;\n              continue;\n            }\n          }\n\n          if (node === current) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === current) {\n              return;\n            }\n\n            node = node['return'];\n\n            if (node.tag === HostPortal) {\n              // When we go out of the portal, we need to restore the parent.\n              // Since we don't keep a stack of them, we will search for it.\n              currentParentIsValid = false;\n            }\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function commitDeletion(current) {\n        // Recursively delete all host nodes from the parent.\n        // Detach refs and call componentWillUnmount() on the whole subtree.\n        unmountHostComponents(current);\n        detachFiber(current);\n      }\n\n      function commitWork(current, finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n\n          case HostComponent:\n            {\n              var instance = finishedWork.stateNode;\n\n              if (instance != null) {\n                // Commit the work prepared earlier.\n                var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                // as the newProps. The updatePayload will contain the real change in\n                // this case.\n\n                var oldProps = current !== null ? current.memoizedProps : newProps;\n                var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n                var updatePayload = finishedWork.updateQueue;\n                finishedWork.updateQueue = null;\n\n                if (updatePayload !== null) {\n                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n                }\n              }\n\n              return;\n            }\n\n          case HostText:\n            {\n              !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              var textInstance = finishedWork.stateNode;\n              var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n              // as the newProps. The updatePayload will contain the real change in\n              // this case.\n\n              var oldText = current !== null ? current.memoizedProps : newText;\n              commitTextUpdate(textInstance, oldText, newText);\n              return;\n            }\n\n          case HostRoot:\n            {\n              return;\n            }\n\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      }\n\n      function commitResetTextContent(current) {\n        resetTextContent(current.stateNode);\n      }\n\n      if (ReactFeatureFlags.enableMutatingReconciler) {\n        return {\n          commitResetTextContent: commitResetTextContent,\n          commitPlacement: commitPlacement,\n          commitDeletion: commitDeletion,\n          commitWork: commitWork,\n          commitLifeCycles: commitLifeCycles,\n          commitAttachRef: commitAttachRef,\n          commitDetachRef: commitDetachRef\n        };\n      } else {\n        invariant(false, 'Mutating reconciler is disabled.');\n      }\n    };\n\n    var NO_CONTEXT = {};\n\n    var ReactFiberHostContext = function ReactFiberHostContext(config) {\n      var getChildHostContext = config.getChildHostContext,\n          getRootHostContext = config.getRootHostContext;\n      var contextStackCursor = createCursor(NO_CONTEXT);\n      var contextFiberStackCursor = createCursor(NO_CONTEXT);\n      var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n      function requiredContext(c) {\n        !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        return c;\n      }\n\n      function getRootHostContainer() {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        return rootInstance;\n      }\n\n      function pushHostContainer(fiber, nextRootInstance) {\n        // Push current root instance onto the stack;\n        // This allows us to reset root when portals are popped.\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        var nextRootContext = getRootHostContext(nextRootInstance); // Track the context and the Fiber that provided it.\n        // This enables us to pop only Fibers that provide unique contexts.\n\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, nextRootContext, fiber);\n      }\n\n      function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n      }\n\n      function getHostContext() {\n        var context = requiredContext(contextStackCursor.current);\n        return context;\n      }\n\n      function pushHostContext(fiber) {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        var context = requiredContext(contextStackCursor.current);\n        var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n        if (context === nextContext) {\n          return;\n        } // Track the context and the Fiber that provided it.\n        // This enables us to pop only Fibers that provide unique contexts.\n\n\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, nextContext, fiber);\n      }\n\n      function popHostContext(fiber) {\n        // Do not pop unless this Fiber provided the current context.\n        // pushHostContext() only pushes Fibers that provide unique contexts.\n        if (contextFiberStackCursor.current !== fiber) {\n          return;\n        }\n\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n      }\n\n      function resetHostContainer() {\n        contextStackCursor.current = NO_CONTEXT;\n        rootInstanceStackCursor.current = NO_CONTEXT;\n      }\n\n      return {\n        getHostContext: getHostContext,\n        getRootHostContainer: getRootHostContainer,\n        popHostContainer: popHostContainer,\n        popHostContext: popHostContext,\n        pushHostContainer: pushHostContainer,\n        pushHostContext: pushHostContext,\n        resetHostContainer: resetHostContainer\n      };\n    };\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n\n\n    var ReactFiberHydrationContext = function ReactFiberHydrationContext(config) {\n      var shouldSetTextContent = config.shouldSetTextContent,\n          hydration = config.hydration; // If this doesn't have hydration mode.\n\n      if (!hydration) {\n        return {\n          enterHydrationState: function enterHydrationState() {\n            return false;\n          },\n          resetHydrationState: function resetHydrationState() {},\n          tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {},\n          prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {\n            invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n          },\n          prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {\n            invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n          },\n          popHydrationState: function popHydrationState(fiber) {\n            return false;\n          }\n        };\n      }\n\n      var canHydrateInstance = hydration.canHydrateInstance,\n          canHydrateTextInstance = hydration.canHydrateTextInstance,\n          getNextHydratableSibling = hydration.getNextHydratableSibling,\n          getFirstHydratableChild = hydration.getFirstHydratableChild,\n          hydrateInstance = hydration.hydrateInstance,\n          hydrateTextInstance = hydration.hydrateTextInstance,\n          didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n          didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n          didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n          didNotHydrateInstance = hydration.didNotHydrateInstance,\n          didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n          didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n          didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n          didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance; // The deepest Fiber on the stack involved in a hydration context.\n      // This may have been an insertion or a hydration.\n\n      var hydrationParentFiber = null;\n      var nextHydratableInstance = null;\n      var isHydrating = false;\n\n      function enterHydrationState(fiber) {\n        var parentInstance = fiber.stateNode.containerInfo;\n        nextHydratableInstance = getFirstHydratableChild(parentInstance);\n        hydrationParentFiber = fiber;\n        isHydrating = true;\n        return true;\n      }\n\n      function deleteHydratableInstance(returnFiber, instance) {\n        {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n              break;\n\n            case HostComponent:\n              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n              break;\n          }\n        }\n        var childToDelete = createFiberFromHostInstanceForDeletion();\n        childToDelete.stateNode = instance;\n        childToDelete['return'] = returnFiber;\n        childToDelete.effectTag = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,\n        // these children are not part of the reconciliation list of children.\n        // Even if we abort and rereconcile the children, that will try to hydrate\n        // again and the nodes are still in the host tree so these will be\n        // recreated.\n\n        if (returnFiber.lastEffect !== null) {\n          returnFiber.lastEffect.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n      }\n\n      function insertNonHydratedInstance(returnFiber, fiber) {\n        fiber.effectTag |= Placement;\n        {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var type = fiber.type;\n                    var props = fiber.pendingProps;\n                    didNotFindHydratableContainerInstance(parentContainer, type, props);\n                    break;\n\n                  case HostText:\n                    var text = fiber.pendingProps;\n                    didNotFindHydratableContainerTextInstance(parentContainer, text);\n                    break;\n                }\n\n                break;\n              }\n\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var _type = fiber.type;\n                    var _props = fiber.pendingProps;\n                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                    break;\n\n                  case HostText:\n                    var _text = fiber.pendingProps;\n                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                    break;\n                }\n\n                break;\n              }\n\n            default:\n              return;\n          }\n        }\n      }\n\n      function canHydrate(fiber, nextInstance) {\n        switch (fiber.tag) {\n          case HostComponent:\n            {\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              return canHydrateInstance(nextInstance, type, props);\n            }\n\n          case HostText:\n            {\n              var text = fiber.pendingProps;\n              return canHydrateTextInstance(nextInstance, text);\n            }\n\n          default:\n            return false;\n        }\n      }\n\n      function tryToClaimNextHydratableInstance(fiber) {\n        if (!isHydrating) {\n          return;\n        }\n\n        var nextInstance = nextHydratableInstance;\n\n        if (!nextInstance) {\n          // Nothing to hydrate. Make it an insertion.\n          insertNonHydratedInstance(hydrationParentFiber, fiber);\n          isHydrating = false;\n          hydrationParentFiber = fiber;\n          return;\n        }\n\n        if (!canHydrate(fiber, nextInstance)) {\n          // If we can't hydrate this instance let's try the next one.\n          // We use this as a heuristic. It's based on intuition and not data so it\n          // might be flawed or unnecessary.\n          nextInstance = getNextHydratableSibling(nextInstance);\n\n          if (!nextInstance || !canHydrate(fiber, nextInstance)) {\n            // Nothing to hydrate. Make it an insertion.\n            insertNonHydratedInstance(hydrationParentFiber, fiber);\n            isHydrating = false;\n            hydrationParentFiber = fiber;\n            return;\n          } // We matched the next one, we'll now assume that the first one was\n          // superfluous and we'll delete it. Since we can't eagerly delete it\n          // we'll have to schedule a deletion. To do that, this node needs a dummy\n          // fiber associated with it.\n\n\n          deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n        }\n\n        fiber.stateNode = nextInstance;\n        hydrationParentFiber = fiber;\n        nextHydratableInstance = getFirstHydratableChild(nextInstance);\n      }\n\n      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n        var instance = fiber.stateNode;\n        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.\n\n        fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update.\n\n        if (updatePayload !== null) {\n          return true;\n        }\n\n        return false;\n      }\n\n      function prepareToHydrateHostTextInstance(fiber) {\n        var textInstance = fiber.stateNode;\n        var textContent = fiber.memoizedProps;\n        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n        {\n          if (shouldUpdate) {\n            // We assume that prepareToHydrateHostTextInstance is called in a context where the\n            // hydration parent is the parent host component of this host text.\n            var returnFiber = hydrationParentFiber;\n\n            if (returnFiber !== null) {\n              switch (returnFiber.tag) {\n                case HostRoot:\n                  {\n                    var parentContainer = returnFiber.stateNode.containerInfo;\n                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                    break;\n                  }\n\n                case HostComponent:\n                  {\n                    var parentType = returnFiber.type;\n                    var parentProps = returnFiber.memoizedProps;\n                    var parentInstance = returnFiber.stateNode;\n                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                    break;\n                  }\n              }\n            }\n          }\n        }\n        return shouldUpdate;\n      }\n\n      function popToNextHostParent(fiber) {\n        var parent = fiber['return'];\n\n        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n          parent = parent['return'];\n        }\n\n        hydrationParentFiber = parent;\n      }\n\n      function popHydrationState(fiber) {\n        if (fiber !== hydrationParentFiber) {\n          // We're deeper than the current hydration context, inside an inserted\n          // tree.\n          return false;\n        }\n\n        if (!isHydrating) {\n          // If we're not currently hydrating but we're in a hydration context, then\n          // we were an insertion and now need to pop up reenter hydration of our\n          // siblings.\n          popToNextHostParent(fiber);\n          isHydrating = true;\n          return false;\n        }\n\n        var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.\n        // We only do this deeper than head and body since they tend to have random\n        // other nodes in them. We also ignore components with pure text content in\n        // side of them.\n        // TODO: Better heuristic.\n\n        if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n          var nextInstance = nextHydratableInstance;\n\n          while (nextInstance) {\n            deleteHydratableInstance(fiber, nextInstance);\n            nextInstance = getNextHydratableSibling(nextInstance);\n          }\n        }\n\n        popToNextHostParent(fiber);\n        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return true;\n      }\n\n      function resetHydrationState() {\n        hydrationParentFiber = null;\n        nextHydratableInstance = null;\n        isHydrating = false;\n      }\n\n      return {\n        enterHydrationState: enterHydrationState,\n        resetHydrationState: resetHydrationState,\n        tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n        prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n        prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n        popHydrationState: popHydrationState\n      };\n    };\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // This lets us hook into Fiber to debug what it's doing.\n    // See https://github.com/facebook/react/pull/8033.\n    // This is not part of the public API, not even for React DevTools.\n    // You may only inject a debugTool if you work on React Fiber itself.\n\n\n    var ReactFiberInstrumentation = {\n      debugTool: null\n    };\n    var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\n    var defaultShowDialog = function defaultShowDialog(capturedError) {\n      return true;\n    };\n\n    var showDialog = defaultShowDialog;\n\n    function logCapturedError(capturedError) {\n      var logError = showDialog(capturedError); // Allow injected showDialog() to prevent default console.error logging.\n      // This enables renderers like ReactNative to better manage redbox behavior.\n\n      if (logError === false) {\n        return;\n      }\n\n      {\n        var componentName = capturedError.componentName,\n            componentStack = capturedError.componentStack,\n            errorBoundaryName = capturedError.errorBoundaryName,\n            errorBoundaryFound = capturedError.errorBoundaryFound,\n            willRetry = capturedError.willRetry;\n        var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n        var errorBoundaryMessage = void 0; // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n\n        if (errorBoundaryFound && errorBoundaryName) {\n          if (willRetry) {\n            errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n          } else {\n            errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n          }\n        } else {\n          errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n        }\n\n        var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n        // We don't include the original error message and JS stack because the browser\n        // has already printed it. Even if the application swallows the error, it is still\n        // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n\n        console.error(combinedMessage);\n      }\n    }\n\n    var invokeGuardedCallback = ReactErrorUtils.invokeGuardedCallback;\n    var hasCaughtError = ReactErrorUtils.hasCaughtError;\n    var clearCaughtError = ReactErrorUtils.clearCaughtError;\n    var recordEffect = ReactDebugFiberPerf$1.recordEffect;\n    var recordScheduleUpdate = ReactDebugFiberPerf$1.recordScheduleUpdate;\n    var startWorkTimer = ReactDebugFiberPerf$1.startWorkTimer;\n    var stopWorkTimer = ReactDebugFiberPerf$1.stopWorkTimer;\n    var stopFailedWorkTimer = ReactDebugFiberPerf$1.stopFailedWorkTimer;\n    var startWorkLoopTimer = ReactDebugFiberPerf$1.startWorkLoopTimer;\n    var stopWorkLoopTimer = ReactDebugFiberPerf$1.stopWorkLoopTimer;\n    var startCommitTimer = ReactDebugFiberPerf$1.startCommitTimer;\n    var stopCommitTimer = ReactDebugFiberPerf$1.stopCommitTimer;\n    var startCommitHostEffectsTimer = ReactDebugFiberPerf$1.startCommitHostEffectsTimer;\n    var stopCommitHostEffectsTimer = ReactDebugFiberPerf$1.stopCommitHostEffectsTimer;\n    var startCommitLifeCyclesTimer = ReactDebugFiberPerf$1.startCommitLifeCyclesTimer;\n    var stopCommitLifeCyclesTimer = ReactDebugFiberPerf$1.stopCommitLifeCyclesTimer;\n    {\n      var didWarnAboutStateTransition = false;\n      var didWarnSetStateChildContext = false;\n      var didWarnStateUpdateForUnmountedComponent = {};\n\n      var warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber) {\n        var componentName = getComponentName(fiber) || 'ReactClass';\n\n        if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n          return;\n        }\n\n        warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease ' + 'check the code for the %s component.', componentName);\n        didWarnStateUpdateForUnmountedComponent[componentName] = true;\n      };\n\n      var warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {\n        switch (ReactDebugCurrentFiber.phase) {\n          case 'getChildContext':\n            if (didWarnSetStateChildContext) {\n              return;\n            }\n\n            warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n            didWarnSetStateChildContext = true;\n            break;\n\n          case 'render':\n            if (didWarnAboutStateTransition) {\n              return;\n            }\n\n            warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n            didWarnAboutStateTransition = true;\n            break;\n        }\n      };\n    }\n\n    var ReactFiberScheduler = function ReactFiberScheduler(config) {\n      var hostContext = ReactFiberHostContext(config);\n      var hydrationContext = ReactFiberHydrationContext(config);\n      var popHostContainer = hostContext.popHostContainer,\n          popHostContext = hostContext.popHostContext,\n          resetHostContainer = hostContext.resetHostContainer;\n\n      var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n          beginWork = _ReactFiberBeginWork.beginWork,\n          beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n      var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n          completeWork = _ReactFiberCompleteWo.completeWork;\n\n      var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n          commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n          commitPlacement = _ReactFiberCommitWork.commitPlacement,\n          commitDeletion = _ReactFiberCommitWork.commitDeletion,\n          commitWork = _ReactFiberCommitWork.commitWork,\n          commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n          commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n          commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n      var now = config.now,\n          scheduleDeferredCallback = config.scheduleDeferredCallback,\n          useSyncScheduling = config.useSyncScheduling,\n          prepareForCommit = config.prepareForCommit,\n          resetAfterCommit = config.resetAfterCommit; // Represents the current time in ms.\n\n      var startTime = now();\n      var mostRecentCurrentTime = msToExpirationTime(0); // Represents the expiration time that incoming updates should use. (If this\n      // is NoWork, use the default strategy: async updates in async mode, sync\n      // updates in sync mode.)\n\n      var expirationContext = NoWork;\n      var isWorking = false; // The next work in progress fiber that we're currently working on.\n\n      var nextUnitOfWork = null;\n      var nextRoot = null; // The time at which we're currently rendering work.\n\n      var nextRenderExpirationTime = NoWork; // The next fiber with an effect that we're currently committing.\n\n      var nextEffect = null; // Keep track of which fibers have captured an error that need to be handled.\n      // Work is removed from this collection after componentDidCatch is called.\n\n      var capturedErrors = null; // Keep track of which fibers have failed during the current batch of work.\n      // This is a different set than capturedErrors, because it is not reset until\n      // the end of the batch. This is needed to propagate errors correctly if a\n      // subtree fails more than once.\n\n      var failedBoundaries = null; // Error boundaries that captured an error during the current commit.\n\n      var commitPhaseBoundaries = null;\n      var firstUncaughtError = null;\n      var didFatal = false;\n      var isCommitting = false;\n      var isUnmounting = false;\n\n      function resetContextStack() {\n        // Reset the stack\n        reset(); // Reset the cursors\n\n        resetContext();\n        resetHostContainer();\n      }\n\n      function commitAllHostEffects() {\n        while (nextEffect !== null) {\n          {\n            ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n            recordEffect();\n          }\n          var effectTag = nextEffect.effectTag;\n\n          if (effectTag & ContentReset) {\n            commitResetTextContent(nextEffect);\n          }\n\n          if (effectTag & Ref) {\n            var current = nextEffect.alternate;\n\n            if (current !== null) {\n              commitDetachRef(current);\n            }\n          } // The following switch statement is only concerned about placement,\n          // updates, and deletions. To avoid needing to add a case for every\n          // possible bitmap value, we remove the secondary effects from the\n          // effect tag and switch on that value.\n\n\n          var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n\n          switch (primaryEffectTag) {\n            case Placement:\n              {\n                commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n                // any life-cycles like componentDidMount gets called.\n                // TODO: findDOMNode doesn't rely on this any more but isMounted\n                // does and isMounted is deprecated anyway so we should be able\n                // to kill this.\n\n                nextEffect.effectTag &= ~Placement;\n                break;\n              }\n\n            case PlacementAndUpdate:\n              {\n                // Placement\n                commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n                // any life-cycles like componentDidMount gets called.\n\n                nextEffect.effectTag &= ~Placement; // Update\n\n                var _current = nextEffect.alternate;\n                commitWork(_current, nextEffect);\n                break;\n              }\n\n            case Update:\n              {\n                var _current2 = nextEffect.alternate;\n                commitWork(_current2, nextEffect);\n                break;\n              }\n\n            case Deletion:\n              {\n                isUnmounting = true;\n                commitDeletion(nextEffect);\n                isUnmounting = false;\n                break;\n              }\n          }\n\n          nextEffect = nextEffect.nextEffect;\n        }\n\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n      }\n\n      function commitAllLifeCycles() {\n        while (nextEffect !== null) {\n          var effectTag = nextEffect.effectTag;\n\n          if (effectTag & (Update | Callback)) {\n            {\n              recordEffect();\n            }\n            var current = nextEffect.alternate;\n            commitLifeCycles(current, nextEffect);\n          }\n\n          if (effectTag & Ref) {\n            {\n              recordEffect();\n            }\n            commitAttachRef(nextEffect);\n          }\n\n          if (effectTag & Err) {\n            {\n              recordEffect();\n            }\n            commitErrorHandling(nextEffect);\n          }\n\n          var next = nextEffect.nextEffect; // Ensure that we clean these up so that we don't accidentally keep them.\n          // I'm not actually sure this matters because we can't reset firstEffect\n          // and lastEffect since they're on every node, not just the effectful\n          // ones. So we have to clean everything as we reuse nodes anyway.\n\n          nextEffect.nextEffect = null; // Ensure that we reset the effectTag here so that we can rely on effect\n          // tags to reason about the current life-cycle.\n\n          nextEffect = next;\n        }\n      }\n\n      function commitRoot(finishedWork) {\n        // We keep track of this so that captureError can collect any boundaries\n        // that capture an error during the commit phase. The reason these aren't\n        // local to this function is because errors that occur during cWU are\n        // captured elsewhere, to prevent the unmount from being interrupted.\n        isWorking = true;\n        isCommitting = true;\n        {\n          startCommitTimer();\n        }\n        var root = finishedWork.stateNode;\n        !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        root.isReadyForCommit = false; // Reset this to null before calling lifecycles\n\n        ReactCurrentOwner.current = null;\n        var firstEffect = void 0;\n\n        if (finishedWork.effectTag > PerformedWork) {\n          // A fiber's effect list consists only of its children, not itself. So if\n          // the root has an effect, we need to add it to the end of the list. The\n          // resulting list is the set that would belong to the root's parent, if\n          // it had one; that is, all the effects in the tree including the root.\n          if (finishedWork.lastEffect !== null) {\n            finishedWork.lastEffect.nextEffect = finishedWork;\n            firstEffect = finishedWork.firstEffect;\n          } else {\n            firstEffect = finishedWork;\n          }\n        } else {\n          // There is no effect on the root.\n          firstEffect = finishedWork.firstEffect;\n        }\n\n        prepareForCommit(); // Commit all the side-effects within a tree. We'll do this in two passes.\n        // The first pass performs all the host insertions, updates, deletions and\n        // ref unmounts.\n\n        nextEffect = firstEffect;\n        {\n          startCommitHostEffectsTimer();\n        }\n\n        while (nextEffect !== null) {\n          var didError = false;\n\n          var _error = void 0;\n\n          {\n            invokeGuardedCallback(null, commitAllHostEffects, null);\n\n            if (hasCaughtError()) {\n              didError = true;\n              _error = clearCaughtError();\n            }\n          }\n\n          if (didError) {\n            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            captureError(nextEffect, _error); // Clean-up\n\n            if (nextEffect !== null) {\n              nextEffect = nextEffect.nextEffect;\n            }\n          }\n        }\n\n        {\n          stopCommitHostEffectsTimer();\n        }\n        resetAfterCommit(); // The work-in-progress tree is now the current tree. This must come after\n        // the first pass of the commit phase, so that the previous tree is still\n        // current during componentWillUnmount, but before the second pass, so that\n        // the finished work is current during componentDidMount/Update.\n\n        root.current = finishedWork; // In the second pass we'll perform all life-cycles and ref callbacks.\n        // Life-cycles happen as a separate pass so that all placements, updates,\n        // and deletions in the entire tree have already been invoked.\n        // This pass also triggers any renderer-specific initial effects.\n\n        nextEffect = firstEffect;\n        {\n          startCommitLifeCyclesTimer();\n        }\n\n        while (nextEffect !== null) {\n          var _didError = false;\n\n          var _error2 = void 0;\n\n          {\n            invokeGuardedCallback(null, commitAllLifeCycles, null);\n\n            if (hasCaughtError()) {\n              _didError = true;\n              _error2 = clearCaughtError();\n            }\n          }\n\n          if (_didError) {\n            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            captureError(nextEffect, _error2);\n\n            if (nextEffect !== null) {\n              nextEffect = nextEffect.nextEffect;\n            }\n          }\n        }\n\n        isCommitting = false;\n        isWorking = false;\n        {\n          stopCommitLifeCyclesTimer();\n          stopCommitTimer();\n        }\n\n        if (typeof onCommitRoot === 'function') {\n          onCommitRoot(finishedWork.stateNode);\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n        } // If we caught any errors during this commit, schedule their boundaries\n        // to update.\n\n\n        if (commitPhaseBoundaries) {\n          commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n          commitPhaseBoundaries = null;\n        }\n\n        if (firstUncaughtError !== null) {\n          var _error3 = firstUncaughtError;\n          firstUncaughtError = null;\n          onUncaughtError(_error3);\n        }\n\n        var remainingTime = root.current.expirationTime;\n\n        if (remainingTime === NoWork) {\n          capturedErrors = null;\n          failedBoundaries = null;\n        }\n\n        return remainingTime;\n      }\n\n      function resetExpirationTime(workInProgress, renderTime) {\n        if (renderTime !== Never && workInProgress.expirationTime === Never) {\n          // The children of this component are hidden. Don't bubble their\n          // expiration times.\n          return;\n        } // Check for pending updates.\n\n\n        var newExpirationTime = getUpdateExpirationTime(workInProgress); // TODO: Calls need to visit stateNode\n        // Bubble up the earliest expiration time.\n\n        var child = workInProgress.child;\n\n        while (child !== null) {\n          if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n            newExpirationTime = child.expirationTime;\n          }\n\n          child = child.sibling;\n        }\n\n        workInProgress.expirationTime = newExpirationTime;\n      }\n\n      function completeUnitOfWork(workInProgress) {\n        while (true) {\n          // The current, flushed, state of this fiber is the alternate.\n          // Ideally nothing should rely on this, but relying on it here\n          // means that we don't need an additional field on the work in\n          // progress.\n          var current = workInProgress.alternate;\n          {\n            ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n          }\n          var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n          {\n            ReactDebugCurrentFiber.resetCurrentFiber();\n          }\n          var returnFiber = workInProgress['return'];\n          var siblingFiber = workInProgress.sibling;\n          resetExpirationTime(workInProgress, nextRenderExpirationTime);\n\n          if (next !== null) {\n            {\n              stopWorkTimer(workInProgress);\n            }\n\n            if (true && ReactFiberInstrumentation_1.debugTool) {\n              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n            } // If completing this work spawned new work, do that next. We'll come\n            // back here again.\n\n\n            return next;\n          }\n\n          if (returnFiber !== null) {\n            // Append all the effects of the subtree and this fiber onto the effect\n            // list of the parent. The completion order of the children affects the\n            // side-effect order.\n            if (returnFiber.firstEffect === null) {\n              returnFiber.firstEffect = workInProgress.firstEffect;\n            }\n\n            if (workInProgress.lastEffect !== null) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n              }\n\n              returnFiber.lastEffect = workInProgress.lastEffect;\n            } // If this fiber had side-effects, we append it AFTER the children's\n            // side-effects. We can perform certain side-effects earlier if\n            // needed, by doing multiple passes over the effect list. We don't want\n            // to schedule our own side-effect on our own list because if end up\n            // reusing children we'll schedule this effect onto itself since we're\n            // at the end.\n\n\n            var effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect list.\n            // PerformedWork effect is read by React DevTools but shouldn't be committed.\n\n            if (effectTag > PerformedWork) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress;\n              } else {\n                returnFiber.firstEffect = workInProgress;\n              }\n\n              returnFiber.lastEffect = workInProgress;\n            }\n          }\n\n          {\n            stopWorkTimer(workInProgress);\n          }\n\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n          }\n\n          if (siblingFiber !== null) {\n            // If there is more work to do in this returnFiber, do that next.\n            return siblingFiber;\n          } else if (returnFiber !== null) {\n            // If there's no more work in this returnFiber. Complete the returnFiber.\n            workInProgress = returnFiber;\n            continue;\n          } else {\n            // We've reached the root.\n            var root = workInProgress.stateNode;\n            root.isReadyForCommit = true;\n            return null;\n          }\n        } // Without this explicit null return Flow complains of invalid return type\n        // TODO Remove the above while(true) loop\n        // eslint-disable-next-line no-unreachable\n\n\n        return null;\n      }\n\n      function performUnitOfWork(workInProgress) {\n        // The current, flushed, state of this fiber is the alternate.\n        // Ideally nothing should rely on this, but relying on it here\n        // means that we don't need an additional field on the work in\n        // progress.\n        var current = workInProgress.alternate; // See if beginning this work spawns more work.\n\n        {\n          startWorkTimer(workInProgress);\n          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n        }\n        var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n        }\n\n        if (next === null) {\n          // If this doesn't spawn new work, complete the current work.\n          next = completeUnitOfWork(workInProgress);\n        }\n\n        ReactCurrentOwner.current = null;\n        return next;\n      }\n\n      function performFailedUnitOfWork(workInProgress) {\n        // The current, flushed, state of this fiber is the alternate.\n        // Ideally nothing should rely on this, but relying on it here\n        // means that we don't need an additional field on the work in\n        // progress.\n        var current = workInProgress.alternate; // See if beginning this work spawns more work.\n\n        {\n          startWorkTimer(workInProgress);\n          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n        }\n        var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n        }\n\n        if (next === null) {\n          // If this doesn't spawn new work, complete the current work.\n          next = completeUnitOfWork(workInProgress);\n        }\n\n        ReactCurrentOwner.current = null;\n        return next;\n      }\n\n      function workLoop(expirationTime) {\n        if (capturedErrors !== null) {\n          // If there are unhandled errors, switch to the slow work loop.\n          // TODO: How to avoid this check in the fast path? Maybe the renderer\n          // could keep track of which roots have unhandled errors and call a\n          // forked version of renderRoot.\n          slowWorkLoopThatChecksForFailedWork(expirationTime);\n          return;\n        }\n\n        if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n          return;\n        }\n\n        if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n          // Flush all expired work.\n          while (nextUnitOfWork !== null) {\n            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n          }\n        } else {\n          // Flush asynchronous work until the deadline runs out of time.\n          while (nextUnitOfWork !== null && !shouldYield()) {\n            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n          }\n        }\n      }\n\n      function slowWorkLoopThatChecksForFailedWork(expirationTime) {\n        if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n          return;\n        }\n\n        if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n          // Flush all expired work.\n          while (nextUnitOfWork !== null) {\n            if (hasCapturedError(nextUnitOfWork)) {\n              // Use a forked version of performUnitOfWork\n              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n            } else {\n              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n            }\n          }\n        } else {\n          // Flush asynchronous work until the deadline runs out of time.\n          while (nextUnitOfWork !== null && !shouldYield()) {\n            if (hasCapturedError(nextUnitOfWork)) {\n              // Use a forked version of performUnitOfWork\n              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n            } else {\n              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n            }\n          }\n        }\n      }\n\n      function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {\n        // We're going to restart the error boundary that captured the error.\n        // Conceptually, we're unwinding the stack. We need to unwind the\n        // context stack, too.\n        unwindContexts(failedWork, boundary); // Restart the error boundary using a forked version of\n        // performUnitOfWork that deletes the boundary's children. The entire\n        // failed subree will be unmounted. During the commit phase, a special\n        // lifecycle method is called on the error boundary, which triggers\n        // a re-render.\n\n        nextUnitOfWork = performFailedUnitOfWork(boundary); // Continue working.\n\n        workLoop(expirationTime);\n      }\n\n      function renderRoot(root, expirationTime) {\n        {\n          startWorkLoopTimer();\n        }\n        !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        isWorking = true; // We're about to mutate the work-in-progress tree. If the root was pending\n        // commit, it no longer is: we'll need to complete it again.\n\n        root.isReadyForCommit = false; // Check if we're starting from a fresh stack, or if we're resuming from\n        // previously yielded work.\n\n        if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {\n          // This is a restart. Reset the stack.\n          resetContextStack();\n          nextRoot = root;\n          nextRenderExpirationTime = expirationTime;\n          nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);\n        }\n\n        var didError = false;\n        var error = null;\n        {\n          invokeGuardedCallback(null, workLoop, null, expirationTime);\n\n          if (hasCaughtError()) {\n            didError = true;\n            error = clearCaughtError();\n          }\n        } // An error was thrown during the render phase.\n\n        while (didError) {\n          if (didFatal) {\n            // This was a fatal error. Don't attempt to recover from it.\n            firstUncaughtError = error;\n            break;\n          }\n\n          var failedWork = nextUnitOfWork;\n\n          if (failedWork === null) {\n            // An error was thrown but there's no current unit of work. This can\n            // happen during the commit phase if there's a bug in the renderer.\n            didFatal = true;\n            continue;\n          } // \"Capture\" the error by finding the nearest boundary. If there is no\n          // error boundary, we use the root.\n\n\n          var boundary = captureError(failedWork, error);\n          !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n          if (didFatal) {\n            // The error we just captured was a fatal error. This happens\n            // when the error propagates to the root more than once.\n            continue;\n          }\n\n          didError = false;\n          error = null;\n          {\n            invokeGuardedCallback(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);\n\n            if (hasCaughtError()) {\n              didError = true;\n              error = clearCaughtError();\n              continue;\n            }\n          } // We're finished working. Exit the error loop.\n\n          break;\n        }\n\n        var uncaughtError = firstUncaughtError; // We're done performing work. Time to clean up.\n\n        isWorking = false;\n        didFatal = false;\n        firstUncaughtError = null;\n        {\n          stopWorkLoopTimer();\n        }\n\n        if (uncaughtError !== null) {\n          onUncaughtError(uncaughtError);\n        }\n\n        return root.isReadyForCommit ? root.current.alternate : null;\n      } // Returns the boundary that captured the error, or null if the error is ignored\n\n\n      function captureError(failedWork, error) {\n        // It is no longer valid because we exited the user code.\n        ReactCurrentOwner.current = null;\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        } // Search for the nearest error boundary.\n\n        var boundary = null; // Passed to logCapturedError()\n\n        var errorBoundaryFound = false;\n        var willRetry = false;\n        var errorBoundaryName = null; // Host containers are a special case. If the failed work itself is a host\n        // container, then it acts as its own boundary. In all other cases, we\n        // ignore the work itself and only search through the parents.\n\n        if (failedWork.tag === HostRoot) {\n          boundary = failedWork;\n\n          if (isFailedBoundary(failedWork)) {\n            // If this root already failed, there must have been an error when\n            // attempting to unmount it. This is a worst-case scenario and\n            // should only be possible if there's a bug in the renderer.\n            didFatal = true;\n          }\n        } else {\n          var node = failedWork['return'];\n\n          while (node !== null && boundary === null) {\n            if (node.tag === ClassComponent) {\n              var instance = node.stateNode;\n\n              if (typeof instance.componentDidCatch === 'function') {\n                errorBoundaryFound = true;\n                errorBoundaryName = getComponentName(node); // Found an error boundary!\n\n                boundary = node;\n                willRetry = true;\n              }\n            } else if (node.tag === HostRoot) {\n              // Treat the root like a no-op error boundary\n              boundary = node;\n            }\n\n            if (isFailedBoundary(node)) {\n              // This boundary is already in a failed state.\n              // If we're currently unmounting, that means this error was\n              // thrown while unmounting a failed subtree. We should ignore\n              // the error.\n              if (isUnmounting) {\n                return null;\n              } // If we're in the commit phase, we should check to see if\n              // this boundary already captured an error during this commit.\n              // This case exists because multiple errors can be thrown during\n              // a single commit without interruption.\n\n\n              if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n                // If so, we should ignore this error.\n                return null;\n              } // The error should propagate to the next boundary -— we keep looking.\n\n\n              boundary = null;\n              willRetry = false;\n            }\n\n            node = node['return'];\n          }\n        }\n\n        if (boundary !== null) {\n          // Add to the collection of failed boundaries. This lets us know that\n          // subsequent errors in this subtree should propagate to the next boundary.\n          if (failedBoundaries === null) {\n            failedBoundaries = new Set();\n          }\n\n          failedBoundaries.add(boundary); // This method is unsafe outside of the begin and complete phases.\n          // We might be in the commit phase when an error is captured.\n          // The risk is that the return path from this Fiber may not be accurate.\n          // That risk is acceptable given the benefit of providing users more context.\n\n          var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n\n          var _componentName = getComponentName(failedWork); // Add to the collection of captured errors. This is stored as a global\n          // map of errors and their component stack location keyed by the boundaries\n          // that capture them. We mostly use this Map as a Set; it's a Map only to\n          // avoid adding a field to Fiber to store the error.\n\n\n          if (capturedErrors === null) {\n            capturedErrors = new Map();\n          }\n\n          var capturedError = {\n            componentName: _componentName,\n            componentStack: _componentStack,\n            error: error,\n            errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n            errorBoundaryFound: errorBoundaryFound,\n            errorBoundaryName: errorBoundaryName,\n            willRetry: willRetry\n          };\n          capturedErrors.set(boundary, capturedError);\n\n          try {\n            logCapturedError(capturedError);\n          } catch (e) {\n            // Prevent cycle if logCapturedError() throws.\n            // A cycle may still occur if logCapturedError renders a component that throws.\n            console.error(e);\n          } // If we're in the commit phase, defer scheduling an update on the\n          // boundary until after the commit is complete\n\n\n          if (isCommitting) {\n            if (commitPhaseBoundaries === null) {\n              commitPhaseBoundaries = new Set();\n            }\n\n            commitPhaseBoundaries.add(boundary);\n          } else {\n            // Otherwise, schedule an update now.\n            // TODO: Is this actually necessary during the render phase? Is it\n            // possible to unwind and continue rendering at the same priority,\n            // without corrupting internal state?\n            scheduleErrorRecovery(boundary);\n          }\n\n          return boundary;\n        } else if (firstUncaughtError === null) {\n          // If no boundary is found, we'll need to throw the error\n          firstUncaughtError = error;\n        }\n\n        return null;\n      }\n\n      function hasCapturedError(fiber) {\n        // TODO: capturedErrors should store the boundary instance, to avoid needing\n        // to check the alternate.\n        return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n      }\n\n      function isFailedBoundary(fiber) {\n        // TODO: failedBoundaries should store the boundary instance, to avoid\n        // needing to check the alternate.\n        return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n      }\n\n      function commitErrorHandling(effectfulFiber) {\n        var capturedError = void 0;\n\n        if (capturedErrors !== null) {\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n\n          if (capturedError == null) {\n            if (effectfulFiber.alternate !== null) {\n              effectfulFiber = effectfulFiber.alternate;\n              capturedError = capturedErrors.get(effectfulFiber);\n              capturedErrors['delete'](effectfulFiber);\n            }\n          }\n        }\n\n        !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n        switch (effectfulFiber.tag) {\n          case ClassComponent:\n            var instance = effectfulFiber.stateNode;\n            var info = {\n              componentStack: capturedError.componentStack\n            }; // Allow the boundary to handle the error, usually by scheduling\n            // an update to itself\n\n            instance.componentDidCatch(capturedError.error, info);\n            return;\n\n          case HostRoot:\n            if (firstUncaughtError === null) {\n              firstUncaughtError = capturedError.error;\n            }\n\n            return;\n\n          default:\n            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      function unwindContexts(from, to) {\n        var node = from;\n\n        while (node !== null) {\n          switch (node.tag) {\n            case ClassComponent:\n              popContextProvider(node);\n              break;\n\n            case HostComponent:\n              popHostContext(node);\n              break;\n\n            case HostRoot:\n              popHostContainer(node);\n              break;\n\n            case HostPortal:\n              popHostContainer(node);\n              break;\n          }\n\n          if (node === to || node.alternate === to) {\n            {\n              stopFailedWorkTimer(node);\n            }\n            break;\n          } else {\n            stopWorkTimer(node);\n          }\n\n          node = node['return'];\n        }\n      }\n\n      function computeAsyncExpiration() {\n        // Given the current clock time, returns an expiration time. We use rounding\n        // to batch like updates together.\n        // Should complete within ~1000ms. 1200ms max.\n        var currentTime = recalculateCurrentTime();\n        var expirationMs = 1000;\n        var bucketSizeMs = 200;\n        return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n      }\n\n      function computeExpirationForFiber(fiber) {\n        var expirationTime = void 0;\n\n        if (expirationContext !== NoWork) {\n          // An explicit expiration context was set;\n          expirationTime = expirationContext;\n        } else if (isWorking) {\n          if (isCommitting) {\n            // Updates that occur during the commit phase should have sync priority\n            // by default.\n            expirationTime = Sync;\n          } else {\n            // Updates during the render phase should expire at the same time as\n            // the work that is being rendered.\n            expirationTime = nextRenderExpirationTime;\n          }\n        } else {\n          // No explicit expiration context was set, and we're not currently\n          // performing work. Calculate a new expiration time.\n          if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {\n            // This is a sync update\n            expirationTime = Sync;\n          } else {\n            // This is an async update\n            expirationTime = computeAsyncExpiration();\n          }\n        }\n\n        return expirationTime;\n      }\n\n      function scheduleWork(fiber, expirationTime) {\n        return scheduleWorkImpl(fiber, expirationTime, false);\n      }\n\n      function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n        {\n          recordScheduleUpdate();\n        }\n        {\n          if (!isErrorRecovery && fiber.tag === ClassComponent) {\n            var instance = fiber.stateNode;\n            warnAboutInvalidUpdates(instance);\n          }\n        }\n        var node = fiber;\n\n        while (node !== null) {\n          // Walk the parent path to the root and update each node's\n          // expiration time.\n          if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n            node.expirationTime = expirationTime;\n          }\n\n          if (node.alternate !== null) {\n            if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n              node.alternate.expirationTime = expirationTime;\n            }\n          }\n\n          if (node['return'] === null) {\n            if (node.tag === HostRoot) {\n              var root = node.stateNode;\n\n              if (!isWorking && root === nextRoot && expirationTime <= nextRenderExpirationTime) {\n                // This is an interruption. Restart the root from the top.\n                nextRoot = null;\n                nextUnitOfWork = null;\n                nextRenderExpirationTime = NoWork;\n              }\n\n              requestWork(root, expirationTime);\n            } else {\n              {\n                if (!isErrorRecovery && fiber.tag === ClassComponent) {\n                  warnAboutUpdateOnUnmounted(fiber);\n                }\n              }\n              return;\n            }\n          }\n\n          node = node['return'];\n        }\n      }\n\n      function scheduleErrorRecovery(fiber) {\n        scheduleWorkImpl(fiber, Sync, true);\n      }\n\n      function recalculateCurrentTime() {\n        // Subtract initial time so it fits inside 32bits\n        var ms = now() - startTime;\n        mostRecentCurrentTime = msToExpirationTime(ms);\n        return mostRecentCurrentTime;\n      }\n\n      function deferredUpdates(fn) {\n        var previousExpirationContext = expirationContext;\n        expirationContext = computeAsyncExpiration();\n\n        try {\n          return fn();\n        } finally {\n          expirationContext = previousExpirationContext;\n        }\n      }\n\n      function syncUpdates(fn) {\n        var previousExpirationContext = expirationContext;\n        expirationContext = Sync;\n\n        try {\n          return fn();\n        } finally {\n          expirationContext = previousExpirationContext;\n        }\n      } // TODO: Everything below this is written as if it has been lifted to the\n      // renderers. I'll do this in a follow-up.\n      // Linked-list of roots\n\n\n      var firstScheduledRoot = null;\n      var lastScheduledRoot = null;\n      var isCallbackScheduled = false;\n      var isRendering = false;\n      var nextFlushedRoot = null;\n      var nextFlushedExpirationTime = NoWork;\n      var deadlineDidExpire = false;\n      var hasUnhandledError = false;\n      var unhandledError = null;\n      var deadline = null;\n      var isBatchingUpdates = false;\n      var isUnbatchingUpdates = false; // Use these to prevent an infinite loop of nested updates\n\n      var NESTED_UPDATE_LIMIT = 1000;\n      var nestedUpdateCount = 0;\n      var timeHeuristicForUnitOfWork = 1; // requestWork is called by the scheduler whenever a root receives an update.\n      // It's up to the renderer to call renderRoot at some point in the future.\n\n      function requestWork(root, expirationTime) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n          invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n        } // Add the root to the schedule.\n        // Check if this root is already part of the schedule.\n\n\n        if (root.nextScheduledRoot === null) {\n          // This root is not already scheduled. Add it.\n          root.remainingExpirationTime = expirationTime;\n\n          if (lastScheduledRoot === null) {\n            firstScheduledRoot = lastScheduledRoot = root;\n            root.nextScheduledRoot = root;\n          } else {\n            lastScheduledRoot.nextScheduledRoot = root;\n            lastScheduledRoot = root;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          }\n        } else {\n          // This root is already scheduled, but its priority may have increased.\n          var remainingExpirationTime = root.remainingExpirationTime;\n\n          if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n            // Update the priority.\n            root.remainingExpirationTime = expirationTime;\n          }\n        }\n\n        if (isRendering) {\n          // Prevent reentrancy. Remaining work will be scheduled at the end of\n          // the currently rendering batch.\n          return;\n        }\n\n        if (isBatchingUpdates) {\n          // Flush work at the end of the batch.\n          if (isUnbatchingUpdates) {\n            // ...unless we're inside unbatchedUpdates, in which case we should\n            // flush it now.\n            performWorkOnRoot(root, Sync);\n          }\n\n          return;\n        } // TODO: Get rid of Sync and use current time?\n\n\n        if (expirationTime === Sync) {\n          performWork(Sync, null);\n        } else if (!isCallbackScheduled) {\n          isCallbackScheduled = true;\n          scheduleDeferredCallback(performAsyncWork);\n        }\n      }\n\n      function findHighestPriorityRoot() {\n        var highestPriorityWork = NoWork;\n        var highestPriorityRoot = null;\n\n        if (lastScheduledRoot !== null) {\n          var previousScheduledRoot = lastScheduledRoot;\n          var root = firstScheduledRoot;\n\n          while (root !== null) {\n            var remainingExpirationTime = root.remainingExpirationTime;\n\n            if (remainingExpirationTime === NoWork) {\n              // This root no longer has work. Remove it from the scheduler.\n              // TODO: This check is redudant, but Flow is confused by the branch\n              // below where we set lastScheduledRoot to null, even though we break\n              // from the loop right after.\n              !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n              if (root === root.nextScheduledRoot) {\n                // This is the only root in the list.\n                root.nextScheduledRoot = null;\n                firstScheduledRoot = lastScheduledRoot = null;\n                break;\n              } else if (root === firstScheduledRoot) {\n                // This is the first root in the list.\n                var next = root.nextScheduledRoot;\n                firstScheduledRoot = next;\n                lastScheduledRoot.nextScheduledRoot = next;\n                root.nextScheduledRoot = null;\n              } else if (root === lastScheduledRoot) {\n                // This is the last root in the list.\n                lastScheduledRoot = previousScheduledRoot;\n                lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n                root.nextScheduledRoot = null;\n                break;\n              } else {\n                previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n                root.nextScheduledRoot = null;\n              }\n\n              root = previousScheduledRoot.nextScheduledRoot;\n            } else {\n              if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n                // Update the priority, if it's higher\n                highestPriorityWork = remainingExpirationTime;\n                highestPriorityRoot = root;\n              }\n\n              if (root === lastScheduledRoot) {\n                break;\n              }\n\n              previousScheduledRoot = root;\n              root = root.nextScheduledRoot;\n            }\n          }\n        } // If the next root is the same as the previous root, this is a nested\n        // update. To prevent an infinite loop, increment the nested update count.\n\n\n        var previousFlushedRoot = nextFlushedRoot;\n\n        if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {\n          nestedUpdateCount++;\n        } else {\n          // Reset whenever we switch roots.\n          nestedUpdateCount = 0;\n        }\n\n        nextFlushedRoot = highestPriorityRoot;\n        nextFlushedExpirationTime = highestPriorityWork;\n      }\n\n      function performAsyncWork(dl) {\n        performWork(NoWork, dl);\n      }\n\n      function performWork(minExpirationTime, dl) {\n        deadline = dl; // Keep working on roots until there's no more work, or until the we reach\n        // the deadlne.\n\n        findHighestPriorityRoot();\n\n        while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {\n          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime); // Find the next highest priority work.\n\n          findHighestPriorityRoot();\n        } // We're done flushing work. Either we ran out of time in this callback,\n        // or there's no more work left with sufficient priority.\n        // If we're inside a callback, set this to false since we just completed it.\n\n\n        if (deadline !== null) {\n          isCallbackScheduled = false;\n        } // If there's work left over, schedule a new callback.\n\n\n        if (nextFlushedRoot !== null && !isCallbackScheduled) {\n          isCallbackScheduled = true;\n          scheduleDeferredCallback(performAsyncWork);\n        } // Clean-up.\n\n\n        deadline = null;\n        deadlineDidExpire = false;\n        nestedUpdateCount = 0;\n\n        if (hasUnhandledError) {\n          var _error4 = unhandledError;\n          unhandledError = null;\n          hasUnhandledError = false;\n          throw _error4;\n        }\n      }\n\n      function performWorkOnRoot(root, expirationTime) {\n        !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        isRendering = true; // Check if this is async work or sync/expired work.\n        // TODO: Pass current time as argument to renderRoot, commitRoot\n\n        if (expirationTime <= recalculateCurrentTime()) {\n          // Flush sync work.\n          var finishedWork = root.finishedWork;\n\n          if (finishedWork !== null) {\n            // This root is already complete. We can commit it.\n            root.finishedWork = null;\n            root.remainingExpirationTime = commitRoot(finishedWork);\n          } else {\n            root.finishedWork = null;\n            finishedWork = renderRoot(root, expirationTime);\n\n            if (finishedWork !== null) {\n              // We've completed the root. Commit it.\n              root.remainingExpirationTime = commitRoot(finishedWork);\n            }\n          }\n        } else {\n          // Flush async work.\n          var _finishedWork = root.finishedWork;\n\n          if (_finishedWork !== null) {\n            // This root is already complete. We can commit it.\n            root.finishedWork = null;\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } else {\n            root.finishedWork = null;\n            _finishedWork = renderRoot(root, expirationTime);\n\n            if (_finishedWork !== null) {\n              // We've completed the root. Check the deadline one more time\n              // before committing.\n              if (!shouldYield()) {\n                // Still time left. Commit the root.\n                root.remainingExpirationTime = commitRoot(_finishedWork);\n              } else {\n                // There's no time left. Mark this root as complete. We'll come\n                // back and commit it later.\n                root.finishedWork = _finishedWork;\n              }\n            }\n          }\n        }\n\n        isRendering = false;\n      } // When working on async work, the reconciler asks the renderer if it should\n      // yield execution. For DOM, we implement this with requestIdleCallback.\n\n\n      function shouldYield() {\n        if (deadline === null) {\n          return false;\n        }\n\n        if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n          return false;\n        }\n\n        deadlineDidExpire = true;\n        return true;\n      } // TODO: Not happy about this hook. Conceptually, renderRoot should return a\n      // tuple of (isReadyForCommit, didError, error)\n\n\n      function onUncaughtError(error) {\n        !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0; // Unschedule this root so we don't work on it again until there's\n        // another update.\n\n        nextFlushedRoot.remainingExpirationTime = NoWork;\n\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      } // TODO: Batching should be implemented at the renderer level, not inside\n      // the reconciler.\n\n\n      function batchedUpdates(fn, a) {\n        var previousIsBatchingUpdates = isBatchingUpdates;\n        isBatchingUpdates = true;\n\n        try {\n          return fn(a);\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates;\n\n          if (!isBatchingUpdates && !isRendering) {\n            performWork(Sync, null);\n          }\n        }\n      } // TODO: Batching should be implemented at the renderer level, not inside\n      // the reconciler.\n\n\n      function unbatchedUpdates(fn) {\n        if (isBatchingUpdates && !isUnbatchingUpdates) {\n          isUnbatchingUpdates = true;\n\n          try {\n            return fn();\n          } finally {\n            isUnbatchingUpdates = false;\n          }\n        }\n\n        return fn();\n      } // TODO: Batching should be implemented at the renderer level, not within\n      // the reconciler.\n\n\n      function flushSync(fn) {\n        var previousIsBatchingUpdates = isBatchingUpdates;\n        isBatchingUpdates = true;\n\n        try {\n          return syncUpdates(fn);\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates;\n          !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n          performWork(Sync, null);\n        }\n      }\n\n      return {\n        computeAsyncExpiration: computeAsyncExpiration,\n        computeExpirationForFiber: computeExpirationForFiber,\n        scheduleWork: scheduleWork,\n        batchedUpdates: batchedUpdates,\n        unbatchedUpdates: unbatchedUpdates,\n        flushSync: flushSync,\n        deferredUpdates: deferredUpdates\n      };\n    };\n\n    {\n      var didWarnAboutNestedUpdates = false;\n    }\n\n    function getContextForSubtree(parentComponent) {\n      if (!parentComponent) {\n        return emptyObject;\n      }\n\n      var fiber = get(parentComponent);\n      var parentContext = findCurrentUnmaskedContext(fiber);\n      return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n    }\n\n    var ReactFiberReconciler = function ReactFiberReconciler(config) {\n      var getPublicInstance = config.getPublicInstance;\n\n      var _ReactFiberScheduler = ReactFiberScheduler(config),\n          computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,\n          computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n          scheduleWork = _ReactFiberScheduler.scheduleWork,\n          batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n          unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n          flushSync = _ReactFiberScheduler.flushSync,\n          deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n      function scheduleTopLevelUpdate(current, element, callback) {\n        {\n          if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n            didWarnAboutNestedUpdates = true;\n            warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n          }\n        }\n        callback = callback === undefined ? null : callback;\n        {\n          warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n        }\n        var expirationTime = void 0; // Check if the top-level element is an async wrapper component. If so,\n        // treat updates to the root as async. This is a bit weird but lets us\n        // avoid a separate `renderAsync` API.\n\n        if (ReactFeatureFlags.enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {\n          expirationTime = computeAsyncExpiration();\n        } else {\n          expirationTime = computeExpirationForFiber(current);\n        }\n\n        var update = {\n          expirationTime: expirationTime,\n          partialState: {\n            element: element\n          },\n          callback: callback,\n          isReplace: false,\n          isForced: false,\n          nextCallback: null,\n          next: null\n        };\n        insertUpdateIntoFiber(current, update);\n        scheduleWork(current, expirationTime);\n      }\n\n      return {\n        createContainer: function createContainer(containerInfo, hydrate) {\n          return createFiberRoot(containerInfo, hydrate);\n        },\n        updateContainer: function updateContainer(element, container, parentComponent, callback) {\n          // TODO: If this is a nested container, this won't be the root.\n          var current = container.current;\n          {\n            if (ReactFiberInstrumentation_1.debugTool) {\n              if (current.alternate === null) {\n                ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n              } else if (element === null) {\n                ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n              } else {\n                ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n              }\n            }\n          }\n          var context = getContextForSubtree(parentComponent);\n\n          if (container.context === null) {\n            container.context = context;\n          } else {\n            container.pendingContext = context;\n          }\n\n          scheduleTopLevelUpdate(current, element, callback);\n        },\n        batchedUpdates: batchedUpdates,\n        unbatchedUpdates: unbatchedUpdates,\n        deferredUpdates: deferredUpdates,\n        flushSync: flushSync,\n        getPublicRootInstance: function getPublicRootInstance(container) {\n          var containerFiber = container.current;\n\n          if (!containerFiber.child) {\n            return null;\n          }\n\n          switch (containerFiber.child.tag) {\n            case HostComponent:\n              return getPublicInstance(containerFiber.child.stateNode);\n\n            default:\n              return containerFiber.child.stateNode;\n          }\n        },\n        findHostInstance: function findHostInstance(fiber) {\n          var hostFiber = findCurrentHostFiber(fiber);\n\n          if (hostFiber === null) {\n            return null;\n          }\n\n          return hostFiber.stateNode;\n        },\n        findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(fiber) {\n          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n          if (hostFiber === null) {\n            return null;\n          }\n\n          return hostFiber.stateNode;\n        }\n      };\n    };\n\n    var ReactFiberReconciler$1 = Object.freeze({\n      default: ReactFiberReconciler\n    });\n    var ReactFiberReconciler$2 = ReactFiberReconciler$1 && ReactFiberReconciler || ReactFiberReconciler$1;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     */\n    // TODO: bundle Flow types with the package.\n    // TODO: decide on the top-level export form.\n    // This is hacky but makes it work with both Rollup and Jest.\n\n    var reactReconciler = ReactFiberReconciler$2['default'] ? ReactFiberReconciler$2['default'] : ReactFiberReconciler$2;\n    module.exports = reactReconciler;\n    return ($$$reconciler || ($$$reconciler = module.exports))(config);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}